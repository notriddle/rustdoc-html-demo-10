searchState.loadedDescShard("core", 0, "The Rust Core Library\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nApproximate number of significant digits in base 10.\nApproximate number of significant digits in base 10.\nMachine epsilon value for <code>f32</code>.\nMachine epsilon value for <code>f64</code>.\nInfinity (∞).\nInfinity (∞).\nNumber of significant digits in base 2.\nNumber of significant digits in base 2.\nThe highest valid code point a <code>char</code> can have, <code>&#39;\\u{10FFFF}&#39;</code>.\nLargest finite <code>f32</code> value.\nLargest finite <code>f64</code> value.\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nMaximum x for which 10x is normal.\nMaximum x for which 10x is normal.\nMaximum possible power of 2 exponent.\nMaximum possible power of 2 exponent.\nThe lowest valid code point a <code>char</code> can have, <code>&#39;\\0&#39;</code>.\nSmallest finite <code>f32</code> value.\nSmallest finite <code>f64</code> value.\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nMinimum x for which 10x is normal.\nMinimum x for which 10x is normal.\nOne greater than the minimum possible normal power of 2 …\nOne greater than the minimum possible normal power of 2 …\nSmallest positive normal <code>f32</code> value.\nSmallest positive normal <code>f64</code> value.\nNot a Number (NaN).\nNot a Number (NaN).\nNegative infinity (−∞).\nNegative infinity (−∞).\nThe radix or base of the internal representation of <code>f32</code>.\nThe radix or base of the internal representation of <code>f64</code>.\n<code>U+FFFD REPLACEMENT CHARACTER</code> (�) is used in Unicode to …\nThe version of Unicode that the Unicode parts of <code>char</code> and …\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nCalculates the offset from a pointer (convenience for …\nCalculates the offset from a pointer (convenience for …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGets the “address” portion of the pointer.\nGets the “address” portion of the pointer.\nComputes the offset that needs to be applied to the …\nComputes the offset that needs to be applied to the …\nTransmute the slice to a slice of another type, ensuring …\nTransmute the mutable slice to a mutable slice of another …\nMemory allocation APIs\nUtilities for dynamic typing or type reflection.\nSIMD and vendor intrinsics module.\nA fixed-size array, denoted <code>[T; N]</code>, for the element type, <code>T</code>…\nUtilities for the array primitive type.\nReturns an iterator over <code>N</code> elements of the slice at a …\nReturns an iterator over <code>N</code> elements of the slice at a …\nReturns an iterator over overlapping windows of <code>N</code> elements …\nReturns <code>Some</code> if the value is within the ASCII range, or …\nConverts this array of bytes into a array of ASCII …\nIf this slice <code>is_ascii</code>, returns it as a slice of ASCII …\nIf this string slice <code>is_ascii</code>, returns it as a slice of …\nIf the value of this byte is within the ASCII range, …\nConverts this array of bytes into a array of ASCII …\nConverts this slice of bytes into a slice of ASCII …\nViews this slice of ASCII characters as a slice of <code>u8</code> …\nConverts a string slice to a byte slice. To convert the …\nConverts a mutable string slice to a mutable byte slice.\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nReturns <code>None</code> if the pointer is null, or else returns a …\n\n\n\nReturns a raw pointer to the slice’s buffer.\nReturns an unsafe mutable pointer to the slice’s buffer.\nConverts a mutable string slice to a raw pointer.\nReturns the two unsafe mutable pointers spanning the slice.\nReturns a mutable slice containing the entire array. …\nReturns a raw pointer to the slice’s buffer.\nReturns a raw pointer to the slice’s buffer.\nConverts a string slice to a raw pointer.\nReturns the two raw pointers spanning the slice.\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\n\n\n\n\nSplit a slice into a prefix, a middle of aligned SIMD …\nSplit a mutable slice into a mutable prefix, a middle of …\n\nReturns a slice containing the entire array. Equivalent to …\n\nViews this slice of ASCII characters as a UTF-8 <code>str</code>.\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nOperations on ASCII strings and characters.\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other …\nUnstable module containing the unstable <code>assert_matches</code> …\nAsserts that two expressions are not equal to each other …\nComposable asynchronous iteration.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBinary searches this slice for a given element. If the …\nBinary searches this slice with a comparator function.\nBinary searches this slice with a key extraction function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe boolean type.\nUtilities for working with borrowed data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates the offset from a pointer in bytes (convenience …\nCalculates the offset from a pointer in bytes (convenience …\nCalculates the offset from a pointer in bytes.\nCalculates the offset from a pointer in bytes.\nCalculates the distance between two pointers. The returned …\nCalculates the distance between two pointers. The returned …\nCalculates the offset from a pointer in bytes (convenience …\nCalculates the offset from a pointer in bytes (convenience …\nAn iterator over the bytes of a string slice.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCasts to a pointer of another type.\nCasts to a pointer of another type.\nChanges constness without changing the type.\nChanges constness without changing the type.\nFinds the closest <code>x</code> not below <code>index</code> where …\nShareable mutable containers.\nEvaluates boolean combinations of configuration flags at …\nA macro for defining <code>#[cfg]</code> match-like statements.\nA character type.\nUtilities for the <code>char</code> primitive type.\nReturns an iterator over the <code>char</code>s of a string slice, and …\nReturns an iterator over the <code>char</code>s of a string slice.\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nReturns an iterator over the slice producing …\nReturns an iterator over the slice producing …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\n\nRestrict a value to a certain interval unless it is NaN.\nRestrict a value to a certain interval unless it is NaN.\nReturns the floating point category of the number. If only …\nReturns the floating point category of the number. If only …\nThe <code>Clone</code> trait for types that cannot be ‘implicitly …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCopies the elements from <code>src</code> into <code>self</code>.\nUtilities for comparing and ordering values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpands to the column number at which it was invoked.\nCauses compilation to fail with the given error message …\nConcatenates literals into a static string slice.\nConcatenates literals into a byte slice.\nConcatenates identifiers into one identifier.\nSame as <code>format_args</code>, but can be used in some const …\nReturns <code>true</code> if the slice contains an element with the …\nReturns <code>true</code> if the given pattern matches a sub-slice of …\nTraits for conversions between types.\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The …\nCopies all elements from <code>src</code> into <code>self</code>, using a memcpy.\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies elements from one part of the slice to another part …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other.\nAsserts that two expressions are not equal to each other.\nCreates an iterator over the UTF-16 encoded code points in …\nThe <code>Default</code> trait for types with a default value.\nReturns the default value of <code>false</code>\nReturns the default value of <code>\\x00</code>\nReturns the default value of <code>()</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates a mutable empty slice.\nCreates an empty slice.\nCreates an empty str\nCreates an empty mutable str\n\nReturns the default value of <code>0.0</code>\nReturns the default value of <code>0.0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\n\n\n\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nPerforms Euclidean division.\nPerforms Euclidean division.\nPerforms Euclidean division.\nPerforms Euclidean division.\nPerforms Euclidean division.\nCalculates the quotient of Euclidean division of <code>self</code> by …\nPerforms Euclidean division.\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nExecutes the destructor (if any) of the pointed-to value.\nBorrows each element mutably and returns an array of …\nBorrows each element and returns an array of references …\nEncodes this character as UTF-16 into the provided <code>u16</code> …\nReturns an iterator of <code>u16</code> over the string encoded as …\nEncodes this character as UTF-8 into the provided byte …\n\n\nReturns <code>true</code> if <code>needle</code> is a suffix of the slice or equal …\nReturns <code>true</code> if the given pattern matches a suffix of this …\nInspects an environment variable at compile time.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChecks that two values are an ASCII case-insensitive match.\nChecks that two slices are an ASCII case-insensitive match.\nChecks that two strings are an ASCII case-insensitive …\nChecks that two values are an ASCII case-insensitive match.\nInterfaces for working with Errors.\nReturns an iterator that produces an escaped version of …\nReturns an iterator that produces an escaped version of a …\nReturns an iterator that yields the literal escape code of …\nReturn an iterator that escapes each char in <code>self</code> with …\nReturns an iterator that yields the literal escape code of …\nReturn an iterator that escapes each char in <code>self</code> with …\nReturns an iterator that yields the hexadecimal Unicode …\nReturn an iterator that escapes each char in <code>self</code> with …\nGets the “address” portion of the pointer, and ‘…\nGets the “address” portion of the pointer, and ‘…\n\nAllows to <code>extend</code> a tuple of collections that also …\n\n\n\nA 32-bit floating point type (specifically, the “binary32…\nConstants for the <code>f32</code> single-precision floating point type.\nA 64-bit floating point type (specifically, the “binary64…\nConstants for the <code>f64</code> double-precision floating point type.\nPlatform-specific types, as defined by C.\nExpands to the file name in which it was invoked.\nFills <code>self</code> with elements by cloning <code>value</code>.\nFills <code>self</code> with elements returned by calling a closure …\nReturns the byte index of the first character of this …\nReturns the first element of the slice, or <code>None</code> if it is …\nReturn an array reference to the first <code>N</code> items in the …\nReturn a mutable array reference to the first <code>N</code> items in …\nReturns a mutable pointer to the first element of the …\nTakes a <code>&amp;[[T; N]]</code>, and flattens it to a <code>&amp;[T]</code>.\nTakes a <code>&amp;mut [[T; N]]</code>, and flattens it to a <code>&amp;mut [T]</code>.\nFinds the closest <code>x</code> not exceeding <code>index</code> where …\nUtilities for formatting and printing strings.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunction pointers, like <code>fn(usize) -&gt; bool</code>.\nConstructs parameters for the other string-formatting …\nSame as <code>format_args</code>, but adds a newline in the end.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nConverts a <code>u8</code> into a <code>char</code>.\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\n\nReturns the argument unchanged.\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\n\nConverts a <code>bool</code> to <code>f32</code> losslessly. The resulting value is …\nConverts <code>u16</code> to <code>f32</code> losslessly.\nReturns the argument unchanged.\nConverts <code>i16</code> to <code>f32</code> losslessly.\nConverts <code>u8</code> to <code>f32</code> losslessly.\nConverts <code>i8</code> to <code>f32</code> losslessly.\nConverts <code>u16</code> to <code>f64</code> losslessly.\nConverts <code>u32</code> to <code>f64</code> losslessly.\nConverts <code>i8</code> to <code>f64</code> losslessly.\nConverts <code>f32</code> to <code>f64</code> losslessly.\nConverts a <code>bool</code> to <code>f64</code> losslessly. The resulting value is …\nConverts <code>i16</code> to <code>f64</code> losslessly.\nConverts <code>i32</code> to <code>f64</code> losslessly.\nReturns the argument unchanged.\nConverts <code>u8</code> to <code>f64</code> losslessly.\nReturns the argument unchanged.\n\nConverts a <code>bool</code> to <code>i8</code> losslessly. The resulting value is <code>0</code> …\nConverts <code>u8</code> to <code>i16</code> losslessly.\nConverts <code>i8</code> to <code>i16</code> losslessly.\nConverts a <code>bool</code> to <code>i16</code> losslessly. The resulting value is <code>0</code>…\nReturns the argument unchanged.\n\nConverts <code>u8</code> to <code>i32</code> losslessly.\nConverts <code>i8</code> to <code>i32</code> losslessly.\nConverts <code>u16</code> to <code>i32</code> losslessly.\nConverts <code>i16</code> to <code>i32</code> losslessly.\nConverts a <code>bool</code> to <code>i32</code> losslessly. The resulting value is <code>0</code>…\n\nReturns the argument unchanged.\nConverts a <code>bool</code> to <code>i64</code> losslessly. The resulting value is <code>0</code>…\nConverts <code>i16</code> to <code>i64</code> losslessly.\nConverts <code>u8</code> to <code>i64</code> losslessly.\nConverts <code>i8</code> to <code>i64</code> losslessly.\nConverts <code>u16</code> to <code>i64</code> losslessly.\nConverts <code>u32</code> to <code>i64</code> losslessly.\n\nReturns the argument unchanged.\nConverts <code>i32</code> to <code>i64</code> losslessly.\nConverts <code>i16</code> to <code>i128</code> losslessly.\nConverts <code>u32</code> to <code>i128</code> losslessly.\nConverts a <code>bool</code> to <code>i128</code> losslessly. The resulting value is …\nConverts <code>i64</code> to <code>i128</code> losslessly.\nConverts <code>u8</code> to <code>i128</code> losslessly.\nConverts <code>u16</code> to <code>i128</code> losslessly.\nReturns the argument unchanged.\n\nConverts <code>i8</code> to <code>i128</code> losslessly.\nConverts <code>i32</code> to <code>i128</code> losslessly.\nConverts <code>u64</code> to <code>i128</code> losslessly.\nReturns the argument unchanged.\n\n\nConverts a <code>bool</code> to <code>u8</code> losslessly. The resulting value is <code>0</code> …\nConverts a <code>bool</code> to <code>u16</code> losslessly. The resulting value is <code>0</code>…\nReturns the argument unchanged.\n\nConverts <code>u8</code> to <code>u16</code> losslessly.\n\nConverts <code>u16</code> to <code>u32</code> losslessly.\n\nUses <code>Ipv4Addr::to_bits</code> to convert an IPv4 address to a …\nConverts <code>u8</code> to <code>u32</code> losslessly.\n\nConverts a <code>bool</code> to <code>u32</code> losslessly. The resulting value is <code>0</code>…\nConverts a <code>char</code> into a <code>u32</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts <code>u32</code> to <code>u64</code> losslessly.\n\nConverts a <code>bool</code> to <code>u64</code> losslessly. The resulting value is <code>0</code>…\nConverts <code>u8</code> to <code>u64</code> losslessly.\n\nConverts a <code>char</code> into a <code>u64</code>.\nConverts <code>u16</code> to <code>u64</code> losslessly.\n\nConverts <code>u64</code> to <code>u128</code> losslessly.\nUses <code>Ipv6Addr::to_bits</code> to convert an IPv6 address to a …\nConverts <code>u16</code> to <code>u128</code> losslessly.\nConverts a <code>char</code> into a <code>u128</code>.\n\nReturns the argument unchanged.\nConverts <code>u8</code> to <code>u128</code> losslessly.\nConverts <code>u32</code> to <code>u128</code> losslessly.\nConverts a <code>bool</code> to <code>u128</code> losslessly. The resulting value is …\nReturns the argument unchanged.\nConverts <code>i16</code> to <code>isize</code> losslessly.\nConverts <code>u8</code> to <code>isize</code> losslessly.\n\nConverts a <code>bool</code> to <code>isize</code> losslessly. The resulting value …\nConverts <code>i8</code> to <code>isize</code> losslessly.\n\n\nConverts <code>u16</code> to <code>usize</code> losslessly.\nConverts <code>u8</code> to <code>usize</code> losslessly.\nReturns the argument unchanged.\nConverts a <code>bool</code> to <code>usize</code> losslessly. The resulting value …\nReturns the argument unchanged.\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nCreate a floating point value from its representation as a …\nCreate a floating point value from its representation as a …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreates a pointer from its raw bits.\nCreates a pointer from its raw bits.\nRaw transmutation from <code>u32</code>.\nRaw transmutation from <code>u64</code>.\nConverts a digit in the given radix to a <code>char</code>.\n\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nCreate a floating point value from its representation as a …\nCreate a floating point value from its representation as a …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreate a floating point value from its representation as a …\nCreate a floating point value from its representation as a …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate an integer value from its memory representation as …\nCreate a native endian integer value from its memory …\nParse a <code>bool</code> from a string.\n\nConverts a string in base 10 to a float. Accepts an …\nConverts a string in base 10 to a float. Accepts an …\n\n\n\n\n\n\n\n\n\n\n\n\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a <code>u32</code> to a <code>char</code>.\nConverts a <code>u32</code> to a <code>char</code>, ignoring validity.\nAsynchronous basic functionality.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns a reference to an element or subslice depending on …\nReturns a subslice of <code>str</code>.\n\n\n\nReturns mutable references to many indices at once.\nReturns mutable references to many indices at once, …\nReturns a mutable reference to an element or subslice …\nReturns a mutable subslice of <code>str</code>.\n\n\n\nReturns a raw pointer to an element or subslice, without …\nReturns a reference to an element or subslice, without …\nReturns an unchecked subslice of <code>str</code>.\n\n\n\nReturns a raw pointer to an element or subslice, without …\nReturns a mutable reference to an element or subslice, …\nReturns a mutable, unchecked subslice of <code>str</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns whether two pointers are guaranteed to be equal.\nReturns whether two pointers are guaranteed to be equal.\nReturns whether two pointers are guaranteed to be inequal.\nReturns whether two pointers are guaranteed to be inequal.\nGeneric hashing support.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHints to compiler that affects how code should be emitted …\nThe 128-bit signed integer type.\nRedundant constants module for the <code>i128</code> primitive type.\nThe 16-bit signed integer type.\nRedundant constants module for the <code>i16</code> primitive type.\nThe 32-bit signed integer type.\nRedundant constants module for the <code>i32</code> primitive type.\nThe 64-bit signed integer type.\nRedundant constants module for the <code>i64</code> primitive type.\nThe 8-bit signed integer type.\nRedundant constants module for the <code>i8</code> primitive type.\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nParses a file as an expression or an item according to the …\nIncludes a file as a reference to a byte array.\nIncludes a UTF-8 encoded file as a string.\n\n\n\n\n\n\n\n\n\n\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\nCreates a consuming iterator, that is, one that moves each …\n\n\n\n\n\n\n\n\n\nCompiler intrinsics.\nTraits, helpers, and type definitions for core I/O …\nReturns whether the pointer is properly aligned for <code>T</code>.\nReturns whether the pointer is properly aligned for <code>T</code>.\nReturns whether the pointer is aligned to <code>align</code>.\nReturns whether the pointer is aligned to <code>align</code>.\nReturns <code>true</code> if this <code>char</code> has the <code>Alphabetic</code> property.\nReturns <code>true</code> if this <code>char</code> satisfies either <code>is_alphabetic()</code> …\nChecks if the value is within the ASCII range.\nChecks if all bytes in this slice are within the ASCII …\nChecks if all characters in this string are within the …\nChecks if the value is within the ASCII range.\nChecks if the value is an ASCII alphabetic character:\nChecks if the value is an ASCII alphabetic character:\nChecks if the value is an ASCII alphanumeric character:\nChecks if the value is an ASCII alphanumeric character:\nChecks if the value is an ASCII control character: U+0000 …\nChecks if the value is an ASCII control character: U+0000 …\nChecks if the value is an ASCII decimal digit: U+0030 ‘0…\nChecks if the value is an ASCII decimal digit: U+0030 ‘0…\nChecks if the value is an ASCII graphic character: U+0021 …\nChecks if the value is an ASCII graphic character: U+0021 …\nChecks if the value is an ASCII hexadecimal digit:\nChecks if the value is an ASCII hexadecimal digit:\nChecks if the value is an ASCII lowercase character: …\nChecks if the value is an ASCII lowercase character: …\nChecks if the value is an ASCII octal digit: U+0030 ‘0’…\nChecks if the value is an ASCII octal digit: U+0030 ‘0’…\nChecks if the value is an ASCII punctuation character:\nChecks if the value is an ASCII punctuation character:\nChecks if the value is an ASCII uppercase character: …\nChecks if the value is an ASCII uppercase character: …\nChecks if the value is an ASCII whitespace character: …\nChecks if the value is an ASCII whitespace character: …\nChecks that <code>index</code>-th byte is the first byte in a UTF-8 …\n\n\n\n\nChecks whether the pattern matches anywhere in the haystack\n\n\nReturns <code>true</code> if this <code>char</code> has the general category for …\nChecks if a <code>char</code> is a digit in the given radix.\nReturns <code>true</code> if the raw slice has a length of 0.\nReturns <code>true</code> if the raw slice has a length of 0.\nReturns <code>true</code> if the slice has a length of 0.\nReturns <code>true</code> if <code>self</code> has a length of zero bytes.\nReturns <code>true</code> if this number is neither infinite nor NaN.\nReturns <code>true</code> if this number is neither infinite nor NaN.\nReturns <code>true</code> if this value is positive infinity or …\nReturns <code>true</code> if this value is positive infinity or …\nReturns <code>true</code> if this <code>char</code> has the <code>Lowercase</code> property.\nReturns <code>true</code> if this value is NaN.\nReturns <code>true</code> if this value is NaN.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if the number is neither zero, infinite, …\nReturns <code>true</code> if the number is neither zero, infinite, …\nReturns <code>true</code> if the pointer is null.\nReturns <code>true</code> if the pointer is null.\nReturns <code>true</code> if this <code>char</code> has one of the general …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\n\n\n\n\n\nChecks whether the pattern matches at the front of the …\n\nReturns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, …\nReturns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, …\nReturns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, …\nReturns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, …\nChecks if the elements of this slice are sorted.\nChecks if the elements of this slice are sorted using the …\nChecks if the elements of this slice are sorted using the …\nReturns <code>true</code> if the number is subnormal.\nReturns <code>true</code> if the number is subnormal.\n\n\n\n\nChecks whether the pattern matches at the back of the …\n\n\nReturns <code>true</code> if this <code>char</code> has the <code>Uppercase</code> property.\nChecks if the value is a Unicode surrogate code point, …\nReturns <code>true</code> if this <code>char</code> has the <code>White_Space</code> property.\nThe pointer-sized signed integer type.\nRedundant constants module for the <code>isize</code> primitive type.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nComposable external iteration.\nReturns an iterator over the slice.\nReturns an iterator that allows modifying each value.\nReturns the last element of the slice, or <code>None</code> if it is …\nReturn an array reference to the last <code>N</code> items in the slice.\nReturn a mutable array reference to the last <code>N</code> items in …\nReturns a mutable reference to the last item in the slice, …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the length of a raw slice.\nReturns the length of a raw slice.\nReturns the number of elements in the slice.\nReturns the length of <code>self</code>.\nReturns the number of 16-bit code units this <code>char</code> would …\nReturns the number of bytes this <code>char</code> would need if …\nExpands to the line number on which it was invoked.\nAn iterator over the lines of a string, as string slices.\nAn iterator over the lines of a string.\nPrints passed tokens into the standard output.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConverts this type to its ASCII lower case equivalent …\nConverts this slice to its ASCII lower case equivalent …\nConverts this string to its ASCII lower case equivalent …\nConverts this value to its ASCII lower case equivalent …\nConverts this type to its ASCII upper case equivalent …\nConverts this slice to its ASCII upper case equivalent …\nConverts this string to its ASCII upper case equivalent …\nConverts this value to its ASCII upper case equivalent …\nReturns an array of the same size as <code>self</code>, with function <code>f</code> …\nCreates a new pointer by mapping <code>self</code>’s address to a new …\nCreates a new pointer by mapping <code>self</code>’s address to a new …\nPrimitive traits and types representing basic properties …\nMasks out bits of the pointer according to a mask.\nMasks out bits of the pointer according to a mask.\nAn iterator over the disjoint matches of a pattern within …\nAn iterator over the disjoint matches of a pattern within …\nReturns whether the given expression matches the provided …\n\nReturns the maximum of the two numbers, ignoring NaN.\nReturns the maximum of the two numbers, ignoring NaN.\nNew code should prefer to use <code>i8::MAX</code> instead.\nNew code should prefer to use <code>i16::MAX</code> instead.\nNew code should prefer to use <code>i32::MAX</code> instead.\nNew code should prefer to use <code>i64::MAX</code> instead.\nNew code should prefer to use <code>i128::MAX</code> instead.\nNew code should prefer to use <code>u8::MAX</code> instead.\nNew code should prefer to use <code>u16::MAX</code> instead.\nNew code should prefer to use <code>u32::MAX</code> instead.\nNew code should prefer to use <code>u64::MAX</code> instead.\nNew code should prefer to use <code>u128::MAX</code> instead.\nNew code should prefer to use <code>isize::MAX</code> instead.\nNew code should prefer to use <code>usize::MAX</code> instead.\nReturns the maximum of the two numbers, propagating NaN.\nReturns the maximum of the two numbers, propagating NaN.\nBasic functions for dealing with memory.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\n\nReturns the minimum of the two numbers, ignoring NaN.\nReturns the minimum of the two numbers, ignoring NaN.\nNew code should prefer to use <code>i8::MIN</code> instead.\nNew code should prefer to use <code>i16::MIN</code> instead.\nNew code should prefer to use <code>i32::MIN</code> instead.\nNew code should prefer to use <code>i64::MIN</code> instead.\nNew code should prefer to use <code>i128::MIN</code> instead.\nNew code should prefer to use <code>u8::MIN</code> instead.\nNew code should prefer to use <code>u16::MIN</code> instead.\nNew code should prefer to use <code>u32::MIN</code> instead.\nNew code should prefer to use <code>u64::MIN</code> instead.\nNew code should prefer to use <code>u128::MIN</code> instead.\nNew code should prefer to use <code>isize::MIN</code> instead.\nNew code should prefer to use <code>usize::MIN</code> instead.\nReturns the minimum of the two numbers, propagating NaN.\nReturns the minimum of the two numbers, propagating NaN.\nExpands to a string that represents the current module …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNetworking primitives for IP communication.\nThe <code>!</code> type, also called “never”.\nReturns the greatest number less than <code>self</code>.\nReturns the greatest number less than <code>self</code>.\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the least number greater than <code>self</code>.\nReturns the least number greater than <code>self</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumeric traits and functions for the built-in numeric …\nCalculates the offset from a pointer.\nCalculates the offset from a pointer.\nCalculates the distance between two pointers. The returned …\nCalculates the distance between two pointers. The returned …\nOverloadable operators.\nOptional values.\nOptionally inspects an environment variable at compile …\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self, overflowing if this is equal to the minimum …\nNegates self in an overflowing fashion.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nOverflowing Euclidean remainder. Calculates …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nPanic support in the standard library.\nPanics the current thread.\nPanic support for core\nParses this string slice into another type.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMoves all consecutive repeated elements to the end of the …\nMoves all but the first of consecutive elements to the end …\nMoves all but the first of consecutive elements to the end …\nReturns the index of the partition point according to the …\nTypes that pin data to a location in memory.\nRaw, unsafe pointers, <code>*const T</code>, and <code>*mut T</code>.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nThe core prelude\nThis module reexports the primitive types to allow usage …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nManually manage memory through raw pointers.\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReads the value from <code>self</code> without moving it. This leaves …\nReads the value from <code>self</code> without moving it. This leaves …\nReads the value from <code>self</code> without moving it. This leaves …\nReads the value from <code>self</code> without moving it. This leaves …\nPerforms a volatile read of the value from <code>self</code> without …\nPerforms a volatile read of the value from <code>self</code> without …\nTakes the reciprocal (inverse) of a number, <code>1/x</code>.\nTakes the reciprocal (inverse) of a number, <code>1/x</code>.\nReferences, <code>&amp;T</code> and <code>&amp;mut T</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\n\n\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least nonnegative remainder of …\nCalculates the least remainder of <code>self (mod rhs)</code>.\nReplaces the value at <code>self</code> with <code>src</code>, returning the old …\nError handling with the <code>Result</code> type.\nReverses the order of elements in the slice, in place.\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReturns the byte index for the first character of the last …\nAn iterator over the disjoint matches of a pattern within …\nAn iterator over the disjoint matches of a pattern within …\nRotates the slice in-place such that the first <code>mid</code> …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nRotates the slice in-place such that the first …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of the given string slice, …\nDivides one mutable array reference into two at an index …\nDivides one array reference into two at an index from the …\nReturns an iterator over mutable subslices separated by …\nSplits the slice on the last element that matches the …\nSplits the string on the last occurrence of the specified …\nAn iterator over substrings of <code>self</code>, separated by …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of this string slice, …\nReturns an iterator over subslices separated by elements …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nReorder the slice such that the element at <code>index</code> after the …\nReorder the slice with a comparator function such that the …\nReorder the slice with a key extraction function such that …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nPortable SIMD module.\nA dynamically-sized view into a contiguous sequence, <code>[T]</code>. …\nSlice management and manipulation.\nCreates a string slice from another string slice, …\nCreates a string slice from another string slice, …\nSorts the slice of floats.\nSorts the slice of floats.\nSorts the slice, but might not preserve the order of equal …\nSorts the slice with a comparator function, but might not …\nSorts the slice with a key extraction function, but might …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of this string slice, …\nDivides one mutable array reference into two at an index.\nDivides one array reference into two at an index.\nSplits a string slice by ASCII whitespace.\nDivides one slice into two at an index.\nDivide one string slice into two at an index.\nDivides one slice into two at an index, returning <code>None</code> if …\nDivide one string slice into two at an index.\nDivides one mutable raw slice into two at an index.\nDivides one mutable slice into two at an index.\nDivide one mutable string slice into two at an index.\nDivides one mutable slice into two at an index, returning …\nDivide one mutable string slice into two at an index.\nDivides one mutable raw slice into two at an index, …\nDivides one mutable slice into two at an index, without …\nDivides one slice into two at an index, without doing …\nReturns the first and all the rest of the elements of the …\nReturn an array reference to the first <code>N</code> items in the …\nReturn a mutable array reference to the first <code>N</code> items in …\nReturns the first and all the rest of the elements of the …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of this string slice, …\nReturns an iterator over mutable subslices separated by …\nReturns the last and all the rest of the elements of the …\nReturn an array reference to the last <code>N</code> items in the slice …\nReturn a mutable array reference to the last <code>N</code> items in …\nReturns the last and all the rest of the elements of the …\nReturns an iterator over mutable subslices separated by …\nSplits the slice on the first element that matches the …\nSplits the string on the first occurrence of the specified …\nAn iterator over substrings of the given string slice, …\nSplits a string slice by whitespace.\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of the given string slice, …\nReturns an iterator over mutable subslices separated by …\n\n\nReturns <code>true</code> if <code>needle</code> is a prefix of the slice or equal …\nReturns <code>true</code> if the given pattern matches a prefix of this …\n\n\n\n\n\n\n\n\n\n\n\n\n\nString slices.\nString manipulation.\nStrict absolute value. Computes <code>self.abs()</code>, panicking if …\nStrict absolute value. Computes <code>self.abs()</code>, panicking if …\nStrict absolute value. Computes <code>self.abs()</code>, panicking if …\nStrict absolute value. Computes <code>self.abs()</code>, panicking if …\nStrict absolute value. Computes <code>self.abs()</code>, panicking if …\nStrict absolute value. Computes <code>self.abs()</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict integer addition. Computes <code>self + rhs</code>, panicking if …\nStrict addition with a signed integer. Computes <code>self + rhs</code>,\nStrict addition with a signed integer. Computes <code>self + rhs</code>,\nStrict addition with a signed integer. Computes <code>self + rhs</code>,\nStrict addition with a signed integer. Computes <code>self + rhs</code>,\nStrict addition with a signed integer. Computes <code>self + rhs</code>,\nStrict addition with a signed integer. Computes <code>self + rhs</code>,\nStrict addition with an unsigned integer. Computes …\nStrict addition with an unsigned integer. Computes …\nStrict addition with an unsigned integer. Computes …\nStrict addition with an unsigned integer. Computes …\nStrict addition with an unsigned integer. Computes …\nStrict addition with an unsigned integer. Computes …\nStrict integer division. Computes <code>self / rhs</code>, panicking if …\nStrict integer division. Computes <code>self / rhs</code>, panicking if …\nStrict integer division. Computes <code>self / rhs</code>, panicking if …\nStrict integer division. Computes <code>self / rhs</code>, panicking if …\nStrict integer division. Computes <code>self / rhs</code>, panicking if …\nStrict integer division. Computes <code>self / rhs</code>. Strict …\nStrict integer division. Computes <code>self / rhs</code>. Strict …\nStrict integer division. Computes <code>self / rhs</code>. Strict …\nStrict integer division. Computes <code>self / rhs</code>. Strict …\nStrict integer division. Computes <code>self / rhs</code>. Strict …\nStrict integer division. Computes <code>self / rhs</code>, panicking if …\nStrict integer division. Computes <code>self / rhs</code>. Strict …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>. …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>. …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>. …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>. …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>. …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>. …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict integer multiplication. Computes <code>self * rhs</code>, …\nStrict negation. Computes <code>-self</code>, panicking if <code>self == MIN</code>.\nStrict negation. Computes <code>-self</code>, panicking if <code>self == MIN</code>.\nStrict negation. Computes <code>-self</code>, panicking if <code>self == MIN</code>.\nStrict negation. Computes <code>-self</code>, panicking if <code>self == MIN</code>.\nStrict negation. Computes <code>-self</code>, panicking if <code>self == MIN</code>.\nStrict negation. Computes <code>-self</code>, panicking unless <code>self == 0</code>…\nStrict negation. Computes <code>-self</code>, panicking unless <code>self == 0</code>…\nStrict negation. Computes <code>-self</code>, panicking unless <code>self == 0</code>…\nStrict negation. Computes <code>-self</code>, panicking unless <code>self == 0</code>…\nStrict negation. Computes <code>-self</code>, panicking unless <code>self == 0</code>…\nStrict negation. Computes <code>-self</code>, panicking if <code>self == MIN</code>.\nStrict negation. Computes <code>-self</code>, panicking unless <code>self == 0</code>…\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict exponentiation. Computes <code>self.pow(exp)</code>, panicking if\nStrict integer remainder. Computes <code>self % rhs</code>, panicking if\nStrict integer remainder. Computes <code>self % rhs</code>, panicking if\nStrict integer remainder. Computes <code>self % rhs</code>, panicking if\nStrict integer remainder. Computes <code>self % rhs</code>, panicking if\nStrict integer remainder. Computes <code>self % rhs</code>, panicking if\nStrict integer remainder. Computes <code>self % rhs</code>. Strict …\nStrict integer remainder. Computes <code>self % rhs</code>. Strict …\nStrict integer remainder. Computes <code>self % rhs</code>. Strict …\nStrict integer remainder. Computes <code>self % rhs</code>. Strict …\nStrict integer remainder. Computes <code>self % rhs</code>. Strict …\nStrict integer remainder. Computes <code>self % rhs</code>, panicking if\nStrict integer remainder. Computes <code>self % rhs</code>. Strict …\nStrict Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>, …\nStrict Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>, …\nStrict Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>, …\nStrict Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>, …\nStrict Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>, …\nStrict Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nStrict Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nStrict Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nStrict Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nStrict Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nStrict Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>, …\nStrict Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift left. Computes <code>self &lt;&lt; rhs</code>, panicking if <code>rhs</code> …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict shift right. Computes <code>self &gt;&gt; rhs</code>, panicking <code>rhs</code> is …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict integer subtraction. Computes <code>self - rhs</code>, panicking …\nStrict subtraction with an unsigned integer. Computes …\nStrict subtraction with an unsigned integer. Computes …\nStrict subtraction with an unsigned integer. Computes …\nStrict subtraction with an unsigned integer. Computes …\nStrict subtraction with an unsigned integer. Computes …\nStrict subtraction with an unsigned integer. Computes …\nStringifies its arguments.\nReturns a subslice with the prefix removed.\nReturns a string slice with the prefix removed.\n\n\n\n\n\nRemoves the pattern from the front of haystack, if it …\n\nReturns a subslice with the suffix removed.\nReturns a string slice with the suffix removed.\n\n\n\n\nRemoves the pattern from the back of haystack, if it …\n\n\nCalculates the offset from a pointer (convenience for …\nCalculates the offset from a pointer (convenience for …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates the distance between two pointers, <em>where it’s </em>…\nCalculates the distance between two pointers, <em>where it’s </em>…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSwaps the values at two mutable locations of the same …\nSwaps two elements in the slice.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nSwaps two elements in the slice, without doing bounds …\nSwaps all elements in <code>self</code> with those in <code>other</code>.\nSynchronization primitives\nRemoves the subslice corresponding to the given range and …\nRemoves the first element of the slice and returns a …\nRemoves the first element of the slice and returns a …\nRemoves the last element of the slice and returns a …\nRemoves the last element of the slice and returns a mutable\nRemoves the subslice corresponding to the given range and …\nTypes and Traits for working with asynchronous tasks.\nReturns <code>Some(f())</code> if the <code>bool</code> is <code>true</code>, or <code>None</code> otherwise.\nReturns <code>Some(t)</code> if the <code>bool</code> is <code>true</code>, or <code>None</code> otherwise.\nTemporal quantification.\nMakes a copy of the value in its ASCII lower case …\nMakes a copy of the value in its ASCII lower case …\nMakes a copy of the value in its ASCII upper case …\nMakes a copy of the value in its ASCII upper case …\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nReturn the memory representation of this floating point …\nReturn the memory representation of this floating point …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nCasts a pointer to its raw bits.\nCasts a pointer to its raw bits.\nRaw transmutation to <code>u32</code>.\nRaw transmutation to <code>u64</code>.\nConverts radians to degrees.\nConverts radians to degrees.\nConverts a <code>char</code> to a digit in the given radix.\nRounds toward zero and converts to any primitive integer …\nRounds toward zero and converts to any primitive integer …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nReturn the memory representation of this floating point …\nReturn the memory representation of this floating point …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturns an iterator that yields the lowercase mapping of …\nReturn the memory representation of this floating point …\nReturn the memory representation of this floating point …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nConverts degrees to radians.\nConverts degrees to radians.\nDecompose a (possibly wide) pointer into its data pointer …\nDecompose a (possibly wide) pointer into its data pointer …\nReturns an iterator that yields the uppercase mapping of …\nIndicates unfinished code.\nReturn the ordering between <code>self</code> and <code>other</code>.\nReturn the ordering between <code>self</code> and <code>other</code>.\nEnables or disables tracing functionality used for …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nTransposes a <code>[MaybeUninit&lt;T&gt;; N]</code> into a <code>MaybeUninit&lt;[T; N]&gt;</code>…\nReturns a string slice with leading and trailing …\nReturns a byte slice with leading and trailing ASCII …\nReturns a string slice with leading and trailing ASCII …\nReturns a byte slice with trailing ASCII whitespace bytes …\nReturns a string slice with trailing ASCII whitespace …\nReturns a byte slice with leading ASCII whitespace bytes …\nReturns a string slice with leading ASCII whitespace …\nReturns a string slice with trailing whitespace removed.\nReturns a string slice with all suffixes that match a …\nReturns a string slice with leading whitespace removed.\nReturns a string slice with all prefixes that match a …\nReturns a string slice with all prefixes and suffixes that …\nReturns a string slice with trailing whitespace removed.\nReturns a string slice with all suffixes that match a …\nReturns a string slice with leading whitespace removed.\nReturns a string slice with all prefixes that match a …\nUnwraps a result or propagates its error.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTries to convert a <code>char</code> into a <code>u8</code>.\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTries to convert a <code>char</code> into a <code>u16</code>.\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA fallible function <code>f</code> applied to each element on array <code>self</code>…\nA finite heterogeneous sequence, <code>(T, U, ..)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe 128-bit unsigned integer type.\nRedundant constants module for the <code>u128</code> primitive type.\nThe 16-bit unsigned integer type.\nRedundant constants module for the <code>u16</code> primitive type.\nThe 32-bit unsigned integer type.\nRedundant constants module for the <code>u32</code> primitive type.\nThe 64-bit unsigned integer type.\nRedundant constants module for the <code>u64</code> primitive type.\nThe 8-bit unsigned integer type.\nRedundant constants module for the <code>u8</code> primitive type.\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\n\nIndicates unimplemented code by panicking with a message …\nThe <code>()</code> type, also called “unit”.\nIndicates unreachable code.\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nThe pointer-sized unsigned integer type.\nRedundant constants module for the <code>usize</code> primitive type.\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nReturns an iterator over all contiguous windows of length …\nCreates a new pointer with the given address.\nCreates a new pointer with the given address.\nUse the pointer value in a new pointer of another type.\nUse the pointer value in a new pointer of another type.\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nOverwrites a memory location with the given value without …\nWrites formatted data into a buffer.\nInvokes memset on the specified pointer, setting …\nOverwrites a memory location with the given value without …\nPerforms a volatile write of a memory location with the …\nWrite formatted data into a buffer, with a newline …\nThe <code>AllocError</code> error indicates an allocation failure that …\nAn implementation of <code>Allocator</code> can allocate, grow, shrink, …\nA memory allocator that can be registered as the standard …\nLayout of a block of memory.\n\nThe parameters given to <code>Layout::from_size_align</code> or some …\nThe minimum byte alignment for a memory block of this …\nCreates a layout describing the record that can hold a …\nAllocate memory as described by the given <code>layout</code>.\nBehaves like <code>alloc</code>, but also ensures that the contents are …\nBehaves like <code>alloc</code>, but also ensures that the contents are …\nAttempts to allocate a block of memory.\nBehaves like <code>allocate</code>, but also ensures that the returned …\nCreates a layout describing the record for a <code>[T; n]</code>.\n\n\n\n\n\n\nCreates a “by reference” adapter for this instance of …\n\n\n\nCreates a <code>NonNull</code> that is dangling, but well-aligned for …\nDeallocate the block of memory at the given <code>ptr</code> pointer …\nDeallocates the memory referenced by <code>ptr</code>.\n\n\n\nCreates a layout describing the record for <code>self</code> followed by\nCreates a layout describing the record for <code>self</code> followed by\n\n\n\n\n\nProduces layout describing a record that could be used to …\nProduces layout describing a record that could be used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>Layout</code> from a given <code>size</code> and <code>align</code>, or …\nCreates a layout, bypassing all checks.\nAttempts to extend the memory block.\nBehaves like <code>grow</code>, but also ensures that the new contents …\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a <code>Layout</code> suitable for holding a value of type <code>T</code>.\nCreates a layout by rounding the size of this layout up to …\nReturns the amount of padding we must insert after <code>self</code> to …\nShrink or grow a block of memory to the given <code>new_size</code> in …\nShrink or grow a block of memory to the given <code>new_size</code> in …\nCreates a layout describing the record for <code>n</code> instances of …\nCreates a layout describing the record for <code>n</code> instances of …\nAttempts to shrink the memory block.\nThe minimum size in bytes for a memory block of this …\n\n\n\n\n\n\n\n\n\nA trait to emulate dynamic typing.\nA <code>TypeId</code> represents a globally unique identifier for a …\n\n\n\n\nReturns some mutable reference to the inner value if it is …\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns a mutable reference to the inner value as type …\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns some reference to the inner value if it is of type …\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns a reference to the inner value as type <code>dyn T</code>.\nForwards to the method defined on the type <code>Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\n\n\n\n\n\nReturns the argument unchanged.\n\nCalls <code>U::from(self)</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns <code>true</code> if the inner type is the same as <code>T</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns the <code>TypeId</code> of the type this generic function has …\n\n\n\nGets the <code>TypeId</code> of <code>self</code>.\n\nReturns the name of a type as a string slice.\nReturns the type name of the pointed-to value as a string …\nPlatform-specific intrinsics for the <code>aarch64</code> platform.\nPlatform-specific intrinsics for the <code>arm</code> platform.\nInline assembly.\nModule-level inline assembly.\nPlatform-specific intrinsics for the <code>mips</code> platform.\nPlatform-specific intrinsics for the <code>mips64</code> platform.\nPlatform-specific intrinsics for the <code>NVPTX</code> platform.\nPlatform-specific intrinsics for the <code>PowerPC</code> platform.\nPlatform-specific intrinsics for the <code>PowerPC64</code> platform.\nPlatform-specific intrinsics for the <code>riscv32</code> platform.\nPlatform-specific intrinsics for the <code>riscv64</code> platform.\nPlatform-specific intrinsics for the <code>wasm</code> target family.\nPlatform-specific intrinsics for the <code>wasm32</code> platform.\nPlatform-specific intrinsics for the <code>wasm64</code> platform.\nPlatform-specific intrinsics for the <code>x86</code> platform.\nPlatform-specific intrinsics for the <code>x86_64</code> platform.\nFull system is the required shareability domain, reads and …\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nTransaction executed a TCANCEL instruction\nTransaction aborted due to a debug trap.\nTransaction aborted because a non-permissible operation …\nFallback error type for any other reason\nTransaction failed from interrupt\nTransaction aborted because a conflict occurred\nTransaction aborted due to transactional nesting level was …\nExtraction mask for failure reason\nTransaction retry is possible.\nTransaction aborted due to read or write set limit was …\nIndicates a TRIVIAL version of TM is available\nTransaction successfully started.\nCRC32 single round checksum for bytes (8 bits).\nCRC32-C single round checksum for bytes (8 bits).\nCRC32-C single round checksum for half words (16 bits).\nCRC32-C single round checksum for words (32 bits).\nCRC32 single round checksum for half words (16 bits).\nCRC32 single round checksum for words (32 bits).\nGenerates a DMB (data memory barrier) instruction or …\nGenerates a DSB (data synchronization barrier) instruction …\nGenerates an ISB (instruction synchronization barrier) …\nGenerates an unspecified no-op instruction.\nGenerates a SEV (send a global event) hint instruction.\nGenerates a send a local event hint instruction.\nCancels the current transaction and discards all state …\nCommits the current transaction. For a nested transaction, …\nStarts a new transaction. When the transaction starts …\nTests if executing inside a transaction. If no transaction …\nGenerates a WFE (wait for event) hint instruction, or …\nGenerates a WFI (wait for interrupt) hint instruction, or …\nGenerates a YIELD hint instruction.\nFetch the cache line that contains address <code>p</code> using the …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARM-specific 64-bit wide vector of two packed <code>f32</code>.\nARM-specific type containing two <code>float32x2_t</code> vectors.\nARM-specific type containing three <code>float32x2_t</code> vectors.\nARM-specific type containing four <code>float32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>f32</code>.\nARM-specific type containing two <code>float32x4_t</code> vectors.\nARM-specific type containing three <code>float32x4_t</code> vectors.\nARM-specific type containing four <code>float32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>f64</code>.\nARM-specific type containing two <code>float64x1_t</code> vectors.\nARM-specific type containing three <code>float64x1_t</code> vectors.\nARM-specific type containing four <code>float64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>f64</code>.\nARM-specific type containing two <code>float64x2_t</code> vectors.\nARM-specific type containing three <code>float64x2_t</code> vectors.\nARM-specific type containing four <code>float64x2_t</code> vectors.\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nARM-specific 64-bit wide vector of four packed <code>i16</code>.\nARM-specific type containing two <code>int16x4_t</code> vectors.\nARM-specific type containing three <code>int16x4_t</code> vectors.\nARM-specific type containing four <code>int16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>i16</code>.\nARM-specific type containing two <code>int16x8_t</code> vectors.\nARM-specific type containing three <code>int16x8_t</code> vectors.\nARM-specific type containing four <code>int16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>i32</code>.\nARM-specific type containing two <code>int32x2_t</code> vectors.\nARM-specific type containing three <code>int32x2_t</code> vectors.\nARM-specific type containing four <code>int32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>i32</code>.\nARM-specific type containing two <code>int32x4_t</code> vectors.\nARM-specific type containing three <code>int32x4_t</code> vectors.\nARM-specific type containing four <code>int32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>i64</code>.\nARM-specific type containing two <code>int64x1_t</code> vectors.\nARM-specific type containing three <code>int64x1_t</code> vectors.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>i64</code>.\nARM-specific type containing two <code>int64x2_t</code> vectors.\nARM-specific type containing three <code>int64x2_t</code> vectors.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>i8</code>.\nARM-specific type containing two <code>int8x16_t</code> vectors.\nARM-specific type containing three <code>int8x16_t</code> vectors.\nARM-specific type containing four <code>int8x16_t</code> vectors.\nARM-specific 64-bit wide vector of eight packed <code>i8</code>.\nARM-specific type containing two <code>int8x8_t</code> vectors.\nARM-specific type containing three <code>int8x8_t</code> vectors.\nARM-specific type containing four <code>int8x8_t</code> vectors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nARM-specific 64-bit wide vector of four packed <code>p16</code>.\nARM-specific type containing two <code>poly16x4_t</code> vectors.\nARM-specific type containing three <code>poly16x4_t</code> vectors.\nARM-specific type containing four <code>poly16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>p16</code>.\nARM-specific type containing two <code>poly16x8_t</code> vectors.\nARM-specific type containing three <code>poly16x8_t</code> vectors.\nARM-specific type containing four <code>poly16x8_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>p64</code>.\nARM-specific type containing two <code>poly64x1_t</code> vectors.\nARM-specific type containing three <code>poly64x1_t</code> vectors.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>p64</code>.\nARM-specific type containing two <code>poly64x2_t</code> vectors.\nARM-specific type containing three <code>poly64x2_t</code> vectors.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>p8</code>.\nARM-specific type containing two <code>poly8x16_t</code> vectors.\nARM-specific type containing three <code>poly8x16_t</code> vectors.\nARM-specific type containing four <code>poly8x16_t</code> vectors.\nARM-specific 64-bit wide polynomial vector of eight packed …\nARM-specific type containing two <code>poly8x8_t</code> vectors.\nARM-specific type containing three <code>poly8x8_t</code> vectors.\nARM-specific type containing four <code>poly8x8_t</code> vectors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARM-specific 64-bit wide vector of four packed <code>u16</code>.\nARM-specific type containing two <code>uint16x4_t</code> vectors.\nARM-specific type containing three <code>uint16x4_t</code> vectors.\nARM-specific type containing four <code>uint16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>u16</code>.\nARM-specific type containing two <code>uint16x8_t</code> vectors.\nARM-specific type containing three <code>uint16x8_t</code> vectors.\nARM-specific type containing four <code>uint16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>u32</code>.\nARM-specific type containing two <code>uint32x2_t</code> vectors.\nARM-specific type containing three <code>uint32x2_t</code> vectors.\nARM-specific type containing four <code>uint32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>u32</code>.\nARM-specific type containing two <code>uint32x4_t</code> vectors.\nARM-specific type containing three <code>uint32x4_t</code> vectors.\nARM-specific type containing four <code>uint32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>u64</code>.\nARM-specific type containing two <code>uint64x1_t</code> vectors.\nARM-specific type containing three <code>uint64x1_t</code> vectors.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>u64</code>.\nARM-specific type containing two <code>uint64x2_t</code> vectors.\nARM-specific type containing three <code>uint64x2_t</code> vectors.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>u8</code>.\nARM-specific type containing two <code>uint8x16_t</code> vectors.\nARM-specific type containing three <code>uint8x16_t</code> vectors.\nARM-specific type containing four <code>uint8x16_t</code> vectors.\nARM-specific 64-bit wide vector of eight packed <code>u8</code>.\nARM-specific type containing two <code>uint8x8_t</code> vectors.\nARM-specific type containing three <code>uint8x8_t</code> vectors.\nARM-specific type containing four <code>uint8x8_t</code> vectors.\n\n\n\n\n\n\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\n\n\n\n\n\n\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nFloating-point absolute difference\nSigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nFloating-point absolute difference\nFloating-point absolute value\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute Value (wrapping).\nAbsolute value (wrapping).\nAbsolute Value (wrapping).\nFloating-point absolute value\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute Value (wrapping).\nAbsolute value (wrapping).\nVector add.\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nSigned Add Long (vector).\nSigned Add Long (vector).\nSigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nSigned Add Long across Vector\nSigned Add Long across Vector\nSigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nSigned Add Long across Vector\nSigned Add Long across Vector\nSigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nVector add.\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nFloating-point add across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nFloating-point add across vector\nFloating-point add across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nSigned Add Wide.\nSigned Add Wide.\nSigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nAES single round decryption.\nAES single round encryption.\nAES inverse mix columns.\nAES mix columns.\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nBitwise Select.\nBitwise Select instructions. This instruction sets each …\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select instructions. This instruction sets each …\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point compare equal\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare equal\nCompare bitwise equal\nCompare bitwise equal\nFloating-point compare equal\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare equal\nFloating-point compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nCompare bitwise equal to zero\nCompare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nFloating-point compare greater than or equal\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than or equal\nCompare greater than or equal\nCompare greater than or equal\nFloating-point compare greater than or equal\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than or equal\nFloating-point compare greater than or equal to zero\nFloating-point compare greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nFloating-point compare greater than or equal to zero\nCompare signed greater than or equal to zero\nFloating-point compare greater than or equal to zero\nFloating-point compare greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nFloating-point compare greater than or equal to zero\nFloating-point compare greater than\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare greater than\nCompare greater than\nCompare greater than\nFloating-point compare greater than\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare greater than\nFloating-point compare greater than zero\nFloating-point compare greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nFloating-point compare greater than zero\nCompare signed greater than zero\nFloating-point compare greater than zero\nFloating-point compare greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nFloating-point compare greater than zero\nFloating-point compare less than or equal\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nFloating-point compare less than or equal\nCompare less than or equal\nCompare less than or equal\nFloating-point compare less than or equal\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nFloating-point compare less than or equal\nFloating-point compare less than or equal to zero\nFloating-point compare less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nFloating-point compare less than or equal to zero\nCompare less than or equal to zero\nFloating-point compare less than or equal to zero\nFloating-point compare less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nFloating-point compare less than or equal to zero\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nFloating-point compare less than\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nFloating-point compare less than\nCompare less than\nCompare less than\nFloating-point compare less than\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nFloating-point compare less than\nFloating-point compare less than zero\nFloating-point compare less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nFloating-point compare less than zero\nCompare less than zero\nFloating-point compare less than zero\nFloating-point compare less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nFloating-point compare less than zero\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nFloating-point convert to lower precision narrow\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to higher precision long\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to lower precision narrow\nFloating-point convert to higher precision long\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to integer, rounding to nearest …\nFloating-point convert to integer, rounding to nearest …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to integer, rounding to nearest …\nFloating-point convert to integer, rounding to nearest …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to lower precision narrow, rounding …\nFloating-point convert to lower precision narrow, rounding …\nFloating-point convert to lower precision narrow, rounding …\nDivide\nDivide\nDivide\nDivide\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused Multiply-subtract to …\nFloating-point fused Multiply-subtract to …\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused Multiply-subtract to …\nFloating-point fused Multiply-subtract to …\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad SIMD&amp;FP register (immediate offset)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nFloating-point maximum number across vector\nFloating-point maximum number across vector\nFloating-point maximum number across vector\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nFloating-point minimum number across vector\nFloating-point minimum number across vector\nFloating-point minimum number across vector\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nFloating-point multiply-add to accumulator\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nSigned multiply-add long\nSigned multiply-add long\nSigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nSigned multiply-add long\nSigned multiply-add long\nSigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nFloating-point multiply-add to accumulator\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nFloating-point multiply-subtract from accumulator\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nSigned multiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nFloating-point multiply-subtract from accumulator\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\n8-bit integer matrix multiply-accumulate\n8-bit integer matrix multiply-accumulate\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nVector move\nVector move\nVector move\nVector move\nVector move\nVector move\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nExtract narrow\nExtract narrow\nExtract narrow\nExtract narrow\nExtract narrow\nExtract narrow\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nPolynomial multiply long\nPolynomial multiply long\nSigned multiply long\nSigned multiply long\nSigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nPolynomial multiply long\nPolynomial multiply long\nSigned multiply long\nSigned multiply long\nSigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nFloating-point add pairwise\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nFloating-point add pairwise\nAdd pairwise\nAdd pairwise\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nFloating-point add pairwise\nFloating-point add pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nFloating-point add pairwise\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFloating-point Maximum Number Pairwise (vector).\nFloating-point Maximum Number Pairwise (vector).\nFloating-point Maximum Number Pairwise (vector).\nFloating-point maximum number pairwise\nFloating-point maximum number pairwise\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFloating-point maximum pairwise\nFloating-point maximum pairwise\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFloating-point Minimum Number Pairwise (vector).\nFloating-point Minimum Number Pairwise (vector).\nFloating-point Minimum Number Pairwise (vector).\nFloating-point minimum number pairwise\nFloating-point minimum number pairwise\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFloating-point minimum pairwise\nFloating-point minimum pairwise\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating absolute value\nSigned saturating absolute value\nSigned saturating absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating absolute value\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply with scalar\nVector saturating doubling long multiply with scalar\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRotate and exclusive OR\nReverse bit order\nReverse bit order\nReverse bit order\nReverse bit order\nReverse bit order\nReverse bit order\nReciprocal estimate.\nReciprocal estimate.\nUnsigned reciprocal estimate\nReciprocal estimate.\nReciprocal estimate.\nReciprocal estimate.\nUnsigned reciprocal estimate\nReciprocal estimate.\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal exponent\nFloating-point reciprocal exponent\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer toward zero\nFloating-point round to 64-bit integer toward zero\nFloating-point round to 64-bit integer toward zero\nFloating-point round to 64-bit integer toward zero\nFloating-point round to integral, toward zero\nFloating-point round to integral, toward zero\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward zero\nFloating-point round to integral, toward zero\nFloating-point round to integral exact, using current …\nFloating-point round to integral exact, using current …\nFloating-point round to integral exact, using current …\nFloating-point round to integral exact, using current …\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nReciprocal square-root estimate.\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nReciprocal square-root estimate.\nReciprocal square-root estimate.\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nReciprocal square-root estimate.\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nSigned rounding shift right and accumulate.\nUnsigned rounding shift right and accumulate.\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nSHA1 hash update accelerator, choose.\nSHA1 fixed rotate.\nSHA1 hash update accelerator, majority.\nSHA1 hash update accelerator, parity.\nSHA1 schedule update accelerator, first part.\nSHA1 schedule update accelerator, second part.\nSHA256 hash update accelerator, upper part.\nSHA256 hash update accelerator.\nSHA256 schedule update accelerator, first part.\nSHA256 schedule update accelerator, second part.\nSHA512 hash update part 2\nSHA512 hash update part 1\nSHA512 schedule update 0\nSHA512 schedule update 1\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nShift left\nShift left\nSigned Shift left\nUnsigned Shift left\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nSigned shift right\nUnsigned shift right\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift left and insert\nShift left and insert\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nSM3PARTW1\nSM3PARTW2\nSM3SS1\nSM3TT1A\nSM3TT1B\nSM3TT2A\nSM3TT2B\nSM4 key\nSM4 encode\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating accumulate of signed value\nUnsigned saturating accumulate of signed value\nUnsigned saturating accumulate of signed value\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating accumulate of signed value\nCalculates the square root of each lane.\nCalculates the square root of each lane.\nCalculates the square root of each lane.\nCalculates the square root of each lane.\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift right and insert\nShift right and insert\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nArm’s documentation\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nArm’s documentation\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore SIMD&amp;FP register (immediate offset)\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nCompare bitwise test bits nonzero\nCompare bitwise test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating accumulate of unsigned value\nSigned saturating accumulate of unsigned value\nSigned saturating accumulate of unsigned value\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating accumulate of unsigned value\nDot product index form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nUnsigned and signed 8-bit integer matrix …\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nExclusive OR and rotate\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nFull system is the required shareability domain, reads and …\nCRC32 single round checksum for bytes (8 bits).\nCRC32-C single round checksum for bytes (8 bits).\nCRC32-C single round checksum for half words (16 bits).\nCRC32-C single round checksum for words (32 bits).\nCRC32 single round checksum for half words (16 bits).\nCRC32 single round checksum for words (32 bits).\nGenerates a DMB (data memory barrier) instruction or …\nGenerates a DSB (data synchronization barrier) instruction …\nGenerates an ISB (instruction synchronization barrier) …\nGenerates an unspecified no-op instruction.\nSigned saturating addition\nSaturating two 16-bit integer additions\nSaturating four 8-bit integer additions\nReturns the 16-bit signed saturated equivalent of\nInsert a QADD instruction\nReturns the 16-bit signed saturated equivalent of\nSigned saturating subtraction\nSaturating two 16-bit integer subtraction\nSaturating two 8-bit integer subtraction\nReturns the 16-bit signed saturated equivalent of\nReturns the 8-bit signed saturated equivalent of\nReturns the 16-bit signed equivalent of\nSelect bytes from each operand according to APSR GE flags\nGenerates a SEV (send a global event) hint instruction.\nGenerates a send a local event hint instruction.\nSigned halving parallel halfword-wise addition.\nSigned halving parallel byte-wise addition.\nSigned halving parallel halfword-wise subtraction.\nSigned halving parallel byte-wise subtraction.\nInsert a SMLABB instruction\nInsert a SMLABT instruction\nDual 16-bit Signed Multiply with Addition of products and …\nInsert a SMLATB instruction\nInsert a SMLATT instruction\nInsert a SMLAWB instruction\nInsert a SMLAWT instruction\nDual 16-bit Signed Multiply with Subtraction  of products …\nSigned Dual Multiply Add.\nSigned Dual Multiply Add Reversed.\nInsert a SMULBB instruction\nInsert a SMULTB instruction\nInsert a SMULTB instruction\nInsert a SMULTT instruction\nInsert a SMULWB instruction\nInsert a SMULWT instruction\nSigned Dual Multiply Subtract.\nSigned Dual Multiply Subtract Reversed.\nInserts a <code>SSUB8</code> instruction.\nSum of 8-bit absolute differences.\nSum of 8-bit absolute differences and constant.\nInserts a <code>USUB8</code> instruction.\nGenerates a WFE (wait for event) hint instruction, or …\nGenerates a WFI (wait for interrupt) hint instruction, or …\nGenerates a YIELD hint instruction.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARM-specific 64-bit wide vector of two packed <code>f32</code>.\nARM-specific type containing two <code>float32x2_t</code> vectors.\nARM-specific type containing three <code>float32x2_t</code> vectors.\nARM-specific type containing four <code>float32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>f32</code>.\nARM-specific type containing two <code>float32x4_t</code> vectors.\nARM-specific type containing three <code>float32x4_t</code> vectors.\nARM-specific type containing four <code>float32x4_t</code> vectors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nARM-specific 32-bit wide vector of two packed <code>i16</code>.\nARM-specific 64-bit wide vector of four packed <code>i16</code>.\nARM-specific type containing two <code>int16x4_t</code> vectors.\nARM-specific type containing three <code>int16x4_t</code> vectors.\nARM-specific type containing four <code>int16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>i16</code>.\nARM-specific type containing two <code>int16x8_t</code> vectors.\nARM-specific type containing three <code>int16x8_t</code> vectors.\nARM-specific type containing four <code>int16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>i32</code>.\nARM-specific type containing two <code>int32x2_t</code> vectors.\nARM-specific type containing three <code>int32x2_t</code> vectors.\nARM-specific type containing four <code>int32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>i32</code>.\nARM-specific type containing two <code>int32x4_t</code> vectors.\nARM-specific type containing three <code>int32x4_t</code> vectors.\nARM-specific type containing four <code>int32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>i64</code>.\nARM-specific type containing two <code>int64x1_t</code> vectors.\nARM-specific type containing three <code>int64x1_t</code> vectors.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>i64</code>.\nARM-specific type containing two <code>int64x2_t</code> vectors.\nARM-specific type containing three <code>int64x2_t</code> vectors.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>i8</code>.\nARM-specific type containing two <code>int8x16_t</code> vectors.\nARM-specific type containing three <code>int8x16_t</code> vectors.\nARM-specific type containing four <code>int8x16_t</code> vectors.\nARM-specific 32-bit wide vector of four packed <code>i8</code>.\nARM-specific 64-bit wide vector of eight packed <code>i8</code>.\nARM-specific type containing two <code>int8x8_t</code> vectors.\nARM-specific type containing three <code>int8x8_t</code> vectors.\nARM-specific type containing four <code>int8x8_t</code> vectors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nARM-specific 64-bit wide vector of four packed <code>p16</code>.\nARM-specific type containing two <code>poly16x4_t</code> vectors.\nARM-specific type containing three <code>poly16x4_t</code> vectors.\nARM-specific type containing four <code>poly16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>p16</code>.\nARM-specific type containing two <code>poly16x8_t</code> vectors.\nARM-specific type containing three <code>poly16x8_t</code> vectors.\nARM-specific type containing four <code>poly16x8_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>p64</code>.\nARM-specific type containing two <code>poly64x1_t</code> vectors.\nARM-specific type containing three <code>poly64x1_t</code> vectors.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>p64</code>.\nARM-specific type containing two <code>poly64x2_t</code> vectors.\nARM-specific type containing three <code>poly64x2_t</code> vectors.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>p8</code>.\nARM-specific type containing two <code>poly8x16_t</code> vectors.\nARM-specific type containing three <code>poly8x16_t</code> vectors.\nARM-specific type containing four <code>poly8x16_t</code> vectors.\nARM-specific 64-bit wide polynomial vector of eight packed …\nARM-specific type containing two <code>poly8x8_t</code> vectors.\nARM-specific type containing three <code>poly8x8_t</code> vectors.\nARM-specific type containing four <code>poly8x8_t</code> vectors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARM-specific 32-bit wide vector of two packed <code>u16</code>.\nARM-specific 64-bit wide vector of four packed <code>u16</code>.\nARM-specific type containing two <code>uint16x4_t</code> vectors.\nARM-specific type containing three <code>uint16x4_t</code> vectors.\nARM-specific type containing four <code>uint16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>u16</code>.\nARM-specific type containing two <code>uint16x8_t</code> vectors.\nARM-specific type containing three <code>uint16x8_t</code> vectors.\nARM-specific type containing four <code>uint16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>u32</code>.\nARM-specific type containing two <code>uint32x2_t</code> vectors.\nARM-specific type containing three <code>uint32x2_t</code> vectors.\nARM-specific type containing four <code>uint32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>u32</code>.\nARM-specific type containing two <code>uint32x4_t</code> vectors.\nARM-specific type containing three <code>uint32x4_t</code> vectors.\nARM-specific type containing four <code>uint32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>u64</code>.\nARM-specific type containing two <code>uint64x1_t</code> vectors.\nARM-specific type containing three <code>uint64x1_t</code> vectors.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>u64</code>.\nARM-specific type containing two <code>uint64x2_t</code> vectors.\nARM-specific type containing three <code>uint64x2_t</code> vectors.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>u8</code>.\nARM-specific type containing two <code>uint8x16_t</code> vectors.\nARM-specific type containing three <code>uint8x16_t</code> vectors.\nARM-specific type containing four <code>uint8x16_t</code> vectors.\nARM-specific 32-bit wide vector of four packed <code>u8</code>.\nARM-specific 64-bit wide vector of eight packed <code>u8</code>.\nARM-specific type containing two <code>uint8x8_t</code> vectors.\nARM-specific type containing three <code>uint8x8_t</code> vectors.\nARM-specific type containing four <code>uint8x8_t</code> vectors.\n\n\n\n\n\n\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\n\n\n\n\n\n\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nSigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nSigned Add Long (vector).\nSigned Add Long (vector).\nSigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nSigned Add Wide.\nSigned Add Wide.\nSigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nAES single round decryption.\nAES single round encryption.\nAES inverse mix columns.\nAES mix columns.\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select instructions. This instruction sets each …\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused Multiply-subtract to …\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused Multiply-subtract to …\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad SIMD&amp;FP register (immediate offset)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nSigned multiply-add long\nSigned multiply-add long\nSigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nSigned multiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\n8-bit integer matrix multiply-accumulate\n8-bit integer matrix multiply-accumulate\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nPolynomial multiply long\nSigned multiply long\nSigned multiply long\nSigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nFloating-point add pairwise\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply with scalar\nVector saturating doubling long multiply with scalar\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nReciprocal estimate.\nUnsigned reciprocal estimate\nReciprocal estimate.\nUnsigned reciprocal estimate\nFloating-point reciprocal step\nFloating-point reciprocal step\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nSHA1 hash update accelerator, choose.\nSHA1 fixed rotate.\nSHA1 hash update accelerator, majority.\nSHA1 hash update accelerator, parity.\nSHA1 schedule update accelerator, first part.\nSHA1 schedule update accelerator, second part.\nSHA256 hash update accelerator, upper part.\nSHA256 hash update accelerator.\nSHA256 schedule update accelerator, first part.\nSHA256 schedule update accelerator, second part.\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore SIMD&amp;FP register (immediate offset)\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nUnsigned and signed 8-bit integer matrix …\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nGenerates the trap instruction <code>BREAK</code>\nGenerates the trap instruction <code>BREAK</code>\nSyscall to be used whenever the <em>assert expression produces </em>…\nx-th thread-block dimension.\ny-th thread-block dimension.\nz-th thread-block dimension.\nx-th thread-block index.\ny-th thread-block index.\nz-th thread-block index.\nx-th block-grid dimension.\ny-th block-grid dimension.\nz-th block-grid dimension.\nSynchronizes all threads in the block.\nx-th thread index.\ny-th thread index.\nz-th thread index.\nFree previously dynamically allocated memory.\nAllocate memory dynamically from a fixed-size heap in …\nGenerates the trap instruction <code>TRAP</code>\nPrint formatted output from a kernel to a host-side output …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\nGenerates the trap instruction <code>TRAP</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Signed Integer\nVector expte.\nVector floor.\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge High\nVector Merge Low\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector xor.\nVSX Unaligned Store\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Signed Integer\nVector expte.\nVector floor.\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge High\nVector Merge Low\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector xor.\nVSX Unaligned Store\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV32.\nAES middle round decryption instruction for RV32.\nAES final round encryption instruction for RV32.\nAES middle round encryption instruction for RV32 with.\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the high half of the Sigma0 transformation, as …\nImplements the low half of the Sigma0 transformation, as …\nImplements the high half of the Sigma1 transformation, as …\nImplements the low half of the Sigma1 transformation, as …\nImplements the Sum0 transformation, as used in the …\nImplements the Sum1 transformation, as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nPlace odd and even bits of the source word into …\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nPlace upper/lower halves of the source register into …\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV64.\nAES middle round decryption instruction for RV64.\nAES final round encryption instruction for RV64.\nAES middle round encryption instruction for RV64.\nThis instruction accelerates the inverse MixColumns step …\nThis instruction implements part of the KeySchedule …\nThis instruction implements part of the KeySchedule …\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by double integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nLoads virtual machine memory by unsigned word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by double integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\n\n\n\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\n\nReturns the argument unchanged.\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCalls <code>U::from(self)</code>.\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\n\n\n\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XNOR of 32-bit masks a and b, and …\nCompute the bitwise XNOR of 64-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nCompute the bitwise XOR of 32-bit masks a and b, and store …\nCompute the bitwise XOR of 64-bit masks a and b, and store …\nLoad 32-bit mask from memory into k.\nLoad 64-bit mask from memory into k.\nCounts the leading most significant zero bits.\nComputes the absolute values of packed 16-bit integers in <code>a</code>…\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nComputes the absolute values of packed 8-bit integers in <code>a</code>.\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds packed single-precision (32-bit) floating-point …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively adds and subtracts packed double-precision …\nAlternatively adds and subtracts packed single-precision …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a …\nComputes the bitwise AND of a packed double-precision …\nComputes the bitwise AND of packed single-precision …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise NOT of packed double-precision …\nComputes the bitwise NOT of packed single-precision …\nComputes the bitwise NOT of 256 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcasts 128 bits from memory (composed of 2 packed …\nBroadcasts 128 bits from memory (composed of 4 packed …\nBroadcasts a double-precision (64-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts 128 bits of integer data from a to all 128-bit …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nCasts vector of type __m128d to type __m256d; the upper …\nCasts vector of type __m256d to type __m128d.\nCast vector of type __m256d to type __m256.\nCasts vector of type __m256d to type __m256i.\nCasts vector of type __m128 to type __m256; the upper 128 …\nCasts vector of type __m256 to type __m128.\nCast vector of type __m256 to type __m256d.\nCasts vector of type __m256 to type __m256i.\nCasts vector of type __m128i to type __m256i; the upper …\nCasts vector of type __m256i to type __m256d.\nCasts vector of type __m256i to type __m256.\nCasts vector of type __m256i to type __m128i.\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nSign-extend 16-bit integers to 32-bit integers.\nSign-extend 16-bit integers to 64-bit integers.\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign-extend 32-bit integers to 64-bit integers.\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign-extend 8-bit integers to 16-bit integers.\nSign-extend 8-bit integers to 32-bit integers.\nSign-extend 8-bit integers to 64-bit integers.\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZero-extend the lower four unsigned 16-bit integers in <code>a</code> …\nZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit …\nConvert packed unsigned 32-bit integers in a to packed …\nZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit …\nZero-extend the lower eight unsigned 8-bit integers in <code>a</code> …\nZero-extend the lower four unsigned 8-bit integers in <code>a</code> to …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 8 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 8 x 32-bit float values in the 256-bit vector …\nReturns the first element of the input vector of …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the first element of the input vector of <code>[8 x i32]</code>.\nReturns the first element of the input vector of …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nComputes the division of each of the 4 packed 64-bit …\nComputes the division of each of the 8 packed 32-bit …\nConditionally multiplies the packed single-precision …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of integer data) from <code>a</code>, …\nExtract 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (of integer data) from <code>a</code> selected with …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nHorizontally subtract adjacent pairs of 32-bit integers in …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nScatter 64-bit integers from a into memory using 32-bit …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 2 …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 4 …\nCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nLoads 256-bits of integer data from unaligned memory into …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nLoads two 128-bit values (composed of 4 packed …\nLoads two 128-bit values (composed of 2 packed …\nLoads two 128-bit values (composed of integer data) from …\nLoad 256-bits (composed of 16 packed 16-bit integers) from …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoad 256-bits (composed of 32 packed 8-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, …\nVertically multiplies each unsigned 8-bit integer from <code>a</code> …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nCreates mask from the most significant bit of each 8-bit …\nSets each bit of the returned mask based on the most …\nSets each bit of the returned mask based on the most …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nComputes the sum of absolute differences (SADs) of …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, …\nMultiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR packed double-precision (64-bit) …\nComputes the bitwise OR packed single-precision (32-bit) …\nComputes the bitwise OR of 256 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nShuffles 256 bits (composed of 4 packed double-precision …\nShuffles 256 bits (composed of 8 packed single-precision …\nShuffles 128-bits (composed of integer data) selected by …\nShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> …\nPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.\nShuffles 64-bit floating-point elements in <code>a</code> across lanes …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nPermutes packed 32-bit integers from <code>a</code> according to the …\nShuffles eight 32-bit floating-point elements in <code>a</code> across …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nComputes the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nComputes the approximate reciprocal square root of packed …\nComputes the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements of returned …\nBroadcasts 32-bit integer <code>a</code> to all elements of returned …\nBroadcasts 64-bit integer <code>a</code> to all elements of returned …\nBroadcasts 8-bit integer <code>a</code> to all elements of returned …\nBroadcasts double-precision (64-bit) floating-point value <code>a</code>…\nBroadcasts single-precision (32-bit) floating-point value <code>a</code>…\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nReturns vector of type __m256d with all elements set to …\nReturns vector of type __m256 with all elements set to …\nReturns vector of type __m256i with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in 128-bit lanes of <code>a</code> using the …\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles 16-bit integers in the high 64 bits of 128-bit …\nShuffles 16-bit integers in the low 64 bits of 128-bit …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns the square root of packed double-precision …\nReturns the square root of packed single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nStores the high and low 128-bit halves (each composed of 4 …\nStores the high and low 128-bit halves (each composed of 2 …\nStores the high and low 128-bit halves (each composed of …\nStore 256-bits (composed of 16 packed 16-bit integers) …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStore 256-bits (composed of 32 packed 8-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nMoves double-precision values from a 256-bit vector of …\nMoves single-precision floating point values from a …\nMoves integer data from a 256-bit integer vector to a …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtracts packed double-precision (64-bit) floating-point …\nSubtracts packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nReturns vector of type <code>__m256d</code> with indeterminate elements.\nReturns vector of type <code>__m256</code> with indeterminate elements. …\nReturns vector of type __m256i with with indeterminate …\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of packed double-precision …\nComputes the bitwise XOR of packed single-precision …\nComputes the bitwise XOR of 256 bits (representing integer …\nZeroes the contents of all XMM or YMM registers.\nZeroes the upper 128 bits of all YMM registers; the lower …\nConstructs a 256-bit floating-point vector of <code>[4 x double]</code> …\nConstructs a 256-bit floating-point vector of <code>[8 x float]</code> …\nConstructs a 256-bit integer vector from a 128-bit integer …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of 512 bits (composed of packed …\nCompute the bitwise AND of 512 bits (representing integer …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of 512 bits (composed of packed …\nCompute the bitwise NOT of 512 bits (representing integer …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nShift 128-bit lanes in a left by imm8 bytes while shifting …\nShift 128-bit lanes in a right by imm8 bytes while …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m512d to type __m128d. This …\nCast vector of type __m512d to type __m256d. This …\nCast vector of type __m512d to type __m512. This intrinsic …\nCast vector of type __m512d to type __m512i. This …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m512 to type __m128. This intrinsic …\nCast vector of type __m512 to type __m256. This intrinsic …\nCast vector of type __m512 to type __m512d. This intrinsic …\nCast vector of type __m512 to type __m512i. This intrinsic …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nCast vector of type __m512i to type __m512d. This …\nCast vector of type __m512i to type __m512. This intrinsic …\nCast vector of type __m512i to type __m128i. This …\nCast vector of type __m512i to type __m256i. This …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nCopy the lower 32-bit integer in a to dst.\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nConverts integer mask into bitmask, storing the result in …\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCopy 16-bit mask a to k.\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nPerforms bitwise OR between k1 and k2, storing the result …\nUnpack and interleave 8 bits from masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 8 packed double-precision …\nLoad 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nLoad 512-bits (composed of 32 packed 16-bit integers) from …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 64 packed 8-bit integers) from …\nLoads 512-bits (composed of 8 packed double-precision …\nLoads 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed signed 16-bit integers in a and b, …\nVertically multiply each unsigned 8-bit integer from a …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nConverts bit mask k1 into an integer value, storing the …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition using …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed unsigned 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication …\nReduce the packed 64-bit integers in a by multiplication …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR using …\nReduce the packed 64-bit integers in a by bitwise OR using …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nCompute the bitwise OR of 512 bits (representing integer …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition. …\nReduce the packed 64-bit integers in a by addition. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND. …\nReduce the packed 64-bit integers in a by bitwise AND. …\nReduce the packed signed 32-bit integers in a by maximum. …\nReduce the packed signed 64-bit integers in a by maximum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by minimum. …\nReduce the packed signed 64-bit integers in a by minimum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication. …\nReduce the packed 64-bit integers in a by multiplication. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR. …\nReduce the packed 64-bit integers in a by bitwise OR. …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 8-bit integer a to all elements of dst.\nBroadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.\nBroadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSet packed 16-bit integers in dst with the supplied values.\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values.\nSet packed 8-bit integers in dst with the supplied values.\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values …\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nReturn vector of type __m512 with all elements set to zero.\nReturn vector of type __m512i with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512i</code> with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 32 packed 16-bit integers) …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 64 packed 8-bit integers) from …\nStores 512-bits (composed of 8 packed double-precision …\nStores 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory using a …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nReturn vector of type __m512 with indeterminate elements. …\nReturn vector of type __m512i with indeterminate elements. …\nReturns vector of type <code>__m512d</code> with indeterminate elements.\nReturns vector of type <code>__m512</code> with indeterminate elements. …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the bitwise XOR of 512 bits (representing integer …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nComputes the absolute value of each of the packed 16-bit …\nComputes the absolute value of each of the packed 32-bit …\nComputes the absolute value of packed 8-bit signed …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds __m128 vectors.\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nAdds the first component of <code>a</code> and <code>b</code>, the other components …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively add and subtract packed double-precision …\nAlternatively add and subtract packed single-precision …\nPerforms one round of an AES decryption flow on data …\nPerforms the last round of an AES decryption flow on data …\nPerforms one round of an AES encryption flow on data …\nPerforms the last round of an AES encryption flow on data …\nPerforms the <code>InvMixColumns</code> transformation on <code>a</code>.\nAssist in expanding the AES cipher key.\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte …\nComputes the bitwise AND of packed double-precision …\nBitwise AND of packed single-precision (32-bit) …\nComputes the bitwise AND of 128 bits (representing integer …\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.\nBitwise AND-NOT of packed single-precision (32-bit) …\nComputes the bitwise NOT of 128 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBlend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit integer vector into a 128-bit …\nCasts a 128-bit integer vector into a 128-bit …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nInvalidates and flushes the cache line that contains <code>p</code> …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower double-precision (64-bit) …\nCompare the lower double-precision (64-bit) floating-point …\nCompares the lower single-precision (32-bit) …\nCompare the lower single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for equality.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for equality. The …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than. …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for less-than.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than. The …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for not-equal.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for inequality. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for not-less-than. …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are ordered. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are unordered. The …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nAlias for <code>_mm_cvtsi32_ss</code>.\nAlias for <code>_mm_cvtss_si32</code>.\nSign extend packed 16-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 16-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts the lower two packed 32-bit integers in <code>a</code> to …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 16-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of <code>a</code> …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 32-bit integers in <code>a</code> to …\nConvert packed unsigned 32-bit integers in a to packed …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nConvert the signed 32-bit integer b to a double-precision …\nConvert the signed 32-bit integer b to a single-precision …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 4 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 4 x 32-bit float values in the 128-bit vector …\nReturns the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the lowest element of <code>a</code>.\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nConverts a 32 bit integer to a 32 bit float. The result …\nExtracts the lowest 32 bit float from the input vector.\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lower single-precision (32-bit) …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nAlias for <code>_mm_cvttss_si32</code>.\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 32-bit integer b to a …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivides __m128 vectors.\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nDivides the first component of <code>b</code> by <code>a</code>, the other …\nReturns the dot product of two __m128d vectors.\nReturns the dot product of two __m128 vectors.\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nReturns the <code>imm8</code> element of <code>a</code>.\nExtracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code>\nExtracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. …\nExtracts a single-precision (32-bit) floating-point …\nExtracts the bit range specified by <code>y</code> from the lower 64 …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nGets the unsigned 32-bit value of the MXCSR control and …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally subtract the adjacent pairs of values …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns a new vector where the <code>imm8</code> element of <code>a</code> is …\nReturns a copy of <code>a</code> with the 32-bit integer from <code>i</code> …\nReturns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted …\nSelect a single value in <code>a</code> to store at some position in <code>b</code>, …\nInserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.\nLoads 128-bits of integer data from unaligned memory. This …\nPerforms a serializing operation on all load-from-memory …\nLoads a double-precision (64-bit) floating-point element …\nConstruct a <code>__m128</code> by duplicating the value read from <code>p</code> …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads a double-precision (64-bit) floating-point element …\nLoads four <code>f32</code> values from <em>aligned</em> memory into a <code>__m128</code>. …\nAlias for <code>_mm_load1_ps</code>\nLoads a 64-bit double-precision value to the low element …\nLoads 128-bits of integer data from memory into a new …\nConstruct a <code>__m128</code> with the lowest element read from <code>p</code> and …\nLoads a double-precision (64-bit) floating-point element …\nLoads a double-precision value into the high-order bits of …\nLoads 64-bit integer from memory into first element of …\nLoads a double-precision value into the low-order bits of …\nLoads 2 double-precision (64-bit) floating-point elements …\nLoads four <code>f32</code> values from aligned memory into a <code>__m128</code> in …\nLoad 128-bits (composed of 8 packed 16-bit integers) from …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoad 128-bits (composed of 16 packed 8-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads four <code>f32</code> values from memory into a <code>__m128</code>. There are …\nLoads 128-bits of integer data from memory into a new …\nLoads unaligned 64-bits of integer data from memory into …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies and then horizontally add signed 16 bit …\nMultiplies corresponding pairs of packed 8-bit unsigned …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nConditionally store 8-bit integer elements from <code>a</code> into …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in th elow 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the maximum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nPerforms a serializing operation on all load-from-memory …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the minimum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nFinds the minimum unsigned 16-bit element in the 128-bit __…\nReturns a vector where the low element is extracted from <code>a</code> …\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code>…\nReturns a <code>__m128</code> with the first component from <code>b</code> and the …\nDuplicate the low double-precision (64-bit) floating-point …\nDuplicate odd-indexed single-precision (32-bit) …\nCombine higher half of <code>a</code> and <code>b</code>. The higher half of <code>b</code> …\nDuplicate even-indexed single-precision (32-bit) …\nCombine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nSubtracts 8-bit unsigned integer values and computes the …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies __m128 vectors.\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nMultiplies the first component of <code>a</code> and <code>b</code>, the other …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies packed 16-bit signed integer values, truncate …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR of <code>a</code> and <code>b</code>.\nBitwise OR of packed single-precision (32-bit) …\nComputes the bitwise OR of 128 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nProvides a hint to the processor that the code sequence is …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nFetch the cache line that contains address <code>p</code> using the …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nReturns the approximate reciprocal of packed …\nReturns the approximate reciprocal of the first …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nReturns the approximate reciprocal square root of packed …\nReturns the approximate reciprocal square root of the …\nSum the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements.\nBroadcasts 32-bit integer <code>a</code> to all elements.\nBroadcasts 64-bit integer <code>a</code> to all elements.\nBroadcasts 8-bit integer <code>a</code> to all elements.\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> with all element set to <code>a</code>.\nSets packed 16-bit integers with the supplied values.\nSets packed 32-bit integers with the supplied values.\nSets packed 64-bit integers with the supplied values, from …\nSets packed 8-bit integers with the supplied values.\nSets packed double-precision (64-bit) floating-point …\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> from four floating point values highest …\nAlias for <code>_mm_set1_ps</code>\nCopies double-precision (64-bit) floating-point element <code>a</code> …\nConstruct a <code>__m128</code> with the lowest element set to <code>a</code> and …\nSets the MXCSR register with the 32-bit unsigned integer …\nSets packed 16-bit integers with the supplied values in …\nSets packed 32-bit integers with the supplied values in …\nSets packed 8-bit integers with the supplied values in …\nSets packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> from four floating point values lowest …\nReturns packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> with all elements initialized to zero.\nReturns a vector with all elements set to zero.\nPerforms a serializing operation on all non-temporal (“…\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA1 …\nCalculate SHA1 state variable E after four rounds of …\nPerforms four rounds of SHA1 operation using an initial …\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA256 …\nPerforms 2 rounds of SHA256 operation using an initial …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code> …\nShuffles packed single-precision (32-bit) floating-point …\nShuffles 16-bit integers in the high 64 bits of <code>a</code> using …\nShuffles 16-bit integers in the low 64 bits of <code>a</code> using the …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns a new vector with the square root of each of the …\nReturns the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nReturns a new vector with the low element of <code>a</code> replaced by …\nReturns the square root of the first single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStores the lower double-precision (64-bit) floating-point …\nStores the lowest 32 bit float of <code>a</code> repeated four times …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores the lower double-precision (64-bit) floating-point …\nStores four 32-bit floats into <em>aligned</em> memory.\nAlias for <code>_mm_store1_ps</code>\nStores the lower 64 bits of a 128-bit vector of …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores the lowest 32 bit float of <code>a</code> into memory.\nStores the upper 64 bits of a 128-bit vector of …\nStores the lower 64-bit integer <code>a</code> to a memory location.\nStores the lower 64 bits of a 128-bit vector of …\nStores 2 double-precision (64-bit) floating-point elements …\nStores four 32-bit floats into <em>aligned</em> memory in reverse …\nStore 128-bits (composed of 8 packed 16-bit integers) from …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStore 128-bits (composed of 16 packed 8-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores four 32-bit floats into memory. There are no …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores a 128-bit floating point vector of <code>[2 x double]</code> to …\nStores <code>a</code> into the memory at <code>mem_addr</code> using a non-temporal …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nStores a 128-bit integer vector to a 128-bit aligned …\nStores a 32-bit integer value in the specified memory …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nSubtracts packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtracts packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtracts __m128 vectors.\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nSubtracts the first component of <code>b</code> from <code>a</code>, the other …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nTests whether the specified bits in <code>a</code> 128-bit integer …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCounts the number of trailing least significant zero bits.\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nReturns vector of type __m128d with indeterminate elements.\nReturns vector of type __m128 with indeterminate elements. …\nReturns vector of type __m128i with indeterminate elements.\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nThe resulting <code>__m128d</code> element is composed by the low-order …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nThe resulting <code>__m128d</code> element is composed by the …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of <code>a</code> and <code>b</code>.\nBitwise exclusive OR of packed single-precision (32-bit) …\nComputes the bitwise XOR of 128 bits (representing integer …\nUnsigned multiply without affecting flags.\nScatter contiguous low order bits of <code>a</code> to the result at …\nGathers the bits of <code>x</code> specified by the <code>mask</code> into the …\nCounts the bits that are set.\nRead a hardware generated 16-bit random value and store …\nRead a hardware generated 32-bit random value and store …\nRead a 16-bit NIST SP800-90B and SP800-90C compliant …\nRead a 32-bit NIST SP800-90B and SP800-90C compliant …\nReads the current value of the processor’s time-stamp …\nStore 32-bit mask from a into memory.\nStore 64-bit mask from a into memory.\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nClears all bits below the least significant zero of <code>x</code> and …\nClears all bits below the least significant zero of <code>x</code> and …\nCounts the number of trailing least significant zero bits.\nSets all bits below the least significant one of <code>x</code> and …\nSets all bits below the least significant one of <code>x</code> and …\nForces a restricted transactional memory (RTM) region to …\nRetrieves the parameter passed to <code>_xabort</code> when <code>_xbegin</code>’s …\nSpecifies the start of a restricted transactional memory …\nSpecifies the end of a restricted transactional memory …\nReads the contents of the extended control register <code>XCR</code> …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nCopies 64-bits from <code>val</code> to the extended control register (…\nQueries whether the processor is executing in a …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEAX register.\nEBX register.\nECX register.\nEDX register.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\nReturns the argument unchanged.\n\n\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\n\n\n\nReturns the argument unchanged.\n\nReturns the argument unchanged.\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDoes the host support the <code>cpuid</code> instruction?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XNOR of 32-bit masks a and b, and …\nCompute the bitwise XNOR of 64-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nCompute the bitwise XOR of 32-bit masks a and b, and store …\nCompute the bitwise XOR of 64-bit masks a and b, and store …\nLoad 32-bit mask from memory into k.\nLoad 64-bit mask from memory into k.\nCounts the leading most significant zero bits.\nCounts the leading most significant zero bits.\nComputes the absolute values of packed 16-bit integers in <code>a</code>…\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nComputes the absolute values of packed 8-bit integers in <code>a</code>.\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds packed single-precision (32-bit) floating-point …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively adds and subtracts packed double-precision …\nAlternatively adds and subtracts packed single-precision …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a …\nComputes the bitwise AND of a packed double-precision …\nComputes the bitwise AND of packed single-precision …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise NOT of packed double-precision …\nComputes the bitwise NOT of packed single-precision …\nComputes the bitwise NOT of 256 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcasts 128 bits from memory (composed of 2 packed …\nBroadcasts 128 bits from memory (composed of 4 packed …\nBroadcasts a double-precision (64-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts 128 bits of integer data from a to all 128-bit …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nCasts vector of type __m128d to type __m256d; the upper …\nCasts vector of type __m256d to type __m128d.\nCast vector of type __m256d to type __m256.\nCasts vector of type __m256d to type __m256i.\nCasts vector of type __m128 to type __m256; the upper 128 …\nCasts vector of type __m256 to type __m128.\nCast vector of type __m256 to type __m256d.\nCasts vector of type __m256 to type __m256i.\nCasts vector of type __m128i to type __m256i; the upper …\nCasts vector of type __m256i to type __m256d.\nCasts vector of type __m256i to type __m256.\nCasts vector of type __m256i to type __m128i.\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nSign-extend 16-bit integers to 32-bit integers.\nSign-extend 16-bit integers to 64-bit integers.\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign-extend 32-bit integers to 64-bit integers.\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign-extend 8-bit integers to 16-bit integers.\nSign-extend 8-bit integers to 32-bit integers.\nSign-extend 8-bit integers to 64-bit integers.\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZero-extend the lower four unsigned 16-bit integers in <code>a</code> …\nZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit …\nConvert packed unsigned 32-bit integers in a to packed …\nZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit …\nZero-extend the lower eight unsigned 8-bit integers in <code>a</code> …\nZero-extend the lower four unsigned 8-bit integers in <code>a</code> to …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 8 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 8 x 32-bit float values in the 256-bit vector …\nReturns the first element of the input vector of …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the first element of the input vector of <code>[8 x i32]</code>.\nReturns the first element of the input vector of …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nComputes the division of each of the 4 packed 64-bit …\nComputes the division of each of the 8 packed 32-bit …\nConditionally multiplies the packed single-precision …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts a 64-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of integer data) from <code>a</code>, …\nExtract 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (of integer data) from <code>a</code> selected with …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nHorizontally subtract adjacent pairs of 32-bit integers in …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nScatter 64-bit integers from a into memory using 32-bit …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and insert the 64-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 2 …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 4 …\nCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nLoads 256-bits of integer data from unaligned memory into …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nLoads two 128-bit values (composed of 4 packed …\nLoads two 128-bit values (composed of 2 packed …\nLoads two 128-bit values (composed of integer data) from …\nLoad 256-bits (composed of 16 packed 16-bit integers) from …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoad 256-bits (composed of 32 packed 8-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, …\nVertically multiplies each unsigned 8-bit integer from <code>a</code> …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nCreates mask from the most significant bit of each 8-bit …\nSets each bit of the returned mask based on the most …\nSets each bit of the returned mask based on the most …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nComputes the sum of absolute differences (SADs) of …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, …\nMultiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR packed double-precision (64-bit) …\nComputes the bitwise OR packed single-precision (32-bit) …\nComputes the bitwise OR of 256 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nShuffles 256 bits (composed of 4 packed double-precision …\nShuffles 256 bits (composed of 8 packed single-precision …\nShuffles 128-bits (composed of integer data) selected by …\nShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> …\nPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.\nShuffles 64-bit floating-point elements in <code>a</code> across lanes …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nPermutes packed 32-bit integers from <code>a</code> according to the …\nShuffles eight 32-bit floating-point elements in <code>a</code> across …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nComputes the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nComputes the approximate reciprocal square root of packed …\nComputes the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements of returned …\nBroadcasts 32-bit integer <code>a</code> to all elements of returned …\nBroadcasts 64-bit integer <code>a</code> to all elements of returned …\nBroadcasts 8-bit integer <code>a</code> to all elements of returned …\nBroadcasts double-precision (64-bit) floating-point value <code>a</code>…\nBroadcasts single-precision (32-bit) floating-point value <code>a</code>…\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nReturns vector of type __m256d with all elements set to …\nReturns vector of type __m256 with all elements set to …\nReturns vector of type __m256i with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in 128-bit lanes of <code>a</code> using the …\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles 16-bit integers in the high 64 bits of 128-bit …\nShuffles 16-bit integers in the low 64 bits of 128-bit …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns the square root of packed double-precision …\nReturns the square root of packed single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nStores the high and low 128-bit halves (each composed of 4 …\nStores the high and low 128-bit halves (each composed of 2 …\nStores the high and low 128-bit halves (each composed of …\nStore 256-bits (composed of 16 packed 16-bit integers) …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStore 256-bits (composed of 32 packed 8-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nMoves double-precision values from a 256-bit vector of …\nMoves single-precision floating point values from a …\nMoves integer data from a 256-bit integer vector to a …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtracts packed double-precision (64-bit) floating-point …\nSubtracts packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nReturns vector of type <code>__m256d</code> with indeterminate elements.\nReturns vector of type <code>__m256</code> with indeterminate elements. …\nReturns vector of type __m256i with with indeterminate …\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of packed double-precision …\nComputes the bitwise XOR of packed single-precision …\nComputes the bitwise XOR of 256 bits (representing integer …\nZeroes the contents of all XMM or YMM registers.\nZeroes the upper 128 bits of all YMM registers; the lower …\nConstructs a 256-bit floating-point vector of <code>[4 x double]</code> …\nConstructs a 256-bit floating-point vector of <code>[8 x float]</code> …\nConstructs a 256-bit integer vector from a 128-bit integer …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of 512 bits (composed of packed …\nCompute the bitwise AND of 512 bits (representing integer …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of 512 bits (composed of packed …\nCompute the bitwise NOT of 512 bits (representing integer …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nShift 128-bit lanes in a left by imm8 bytes while shifting …\nShift 128-bit lanes in a right by imm8 bytes while …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m512d to type __m128d. This …\nCast vector of type __m512d to type __m256d. This …\nCast vector of type __m512d to type __m512. This intrinsic …\nCast vector of type __m512d to type __m512i. This …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m512 to type __m128. This intrinsic …\nCast vector of type __m512 to type __m256. This intrinsic …\nCast vector of type __m512 to type __m512d. This intrinsic …\nCast vector of type __m512 to type __m512i. This intrinsic …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nCast vector of type __m512i to type __m512d. This …\nCast vector of type __m512i to type __m512. This intrinsic …\nCast vector of type __m512i to type __m128i. This …\nCast vector of type __m512i to type __m256i. This …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nCopy the lower 32-bit integer in a to dst.\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nConverts integer mask into bitmask, storing the result in …\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCopy 16-bit mask a to k.\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nPerforms bitwise OR between k1 and k2, storing the result …\nUnpack and interleave 8 bits from masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 8 packed double-precision …\nLoad 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nLoad 512-bits (composed of 32 packed 16-bit integers) from …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 64 packed 8-bit integers) from …\nLoads 512-bits (composed of 8 packed double-precision …\nLoads 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed signed 16-bit integers in a and b, …\nVertically multiply each unsigned 8-bit integer from a …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nConverts bit mask k1 into an integer value, storing the …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition using …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed unsigned 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication …\nReduce the packed 64-bit integers in a by multiplication …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR using …\nReduce the packed 64-bit integers in a by bitwise OR using …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nCompute the bitwise OR of 512 bits (representing integer …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition. …\nReduce the packed 64-bit integers in a by addition. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND. …\nReduce the packed 64-bit integers in a by bitwise AND. …\nReduce the packed signed 32-bit integers in a by maximum. …\nReduce the packed signed 64-bit integers in a by maximum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by minimum. …\nReduce the packed signed 64-bit integers in a by minimum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication. …\nReduce the packed 64-bit integers in a by multiplication. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR. …\nReduce the packed 64-bit integers in a by bitwise OR. …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 8-bit integer a to all elements of dst.\nBroadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.\nBroadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSet packed 16-bit integers in dst with the supplied values.\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values.\nSet packed 8-bit integers in dst with the supplied values.\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values …\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nReturn vector of type __m512 with all elements set to zero.\nReturn vector of type __m512i with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512i</code> with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 32 packed 16-bit integers) …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 64 packed 8-bit integers) from …\nStores 512-bits (composed of 8 packed double-precision …\nStores 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory using a …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nReturn vector of type __m512 with indeterminate elements. …\nReturn vector of type __m512i with indeterminate elements. …\nReturns vector of type <code>__m512d</code> with indeterminate elements.\nReturns vector of type <code>__m512</code> with indeterminate elements. …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the bitwise XOR of 512 bits (representing integer …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nComputes the absolute value of each of the packed 16-bit …\nComputes the absolute value of each of the packed 32-bit …\nComputes the absolute value of packed 8-bit signed …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds __m128 vectors.\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nAdds the first component of <code>a</code> and <code>b</code>, the other components …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively add and subtract packed double-precision …\nAlternatively add and subtract packed single-precision …\nPerforms one round of an AES decryption flow on data …\nPerforms the last round of an AES decryption flow on data …\nPerforms one round of an AES encryption flow on data …\nPerforms the last round of an AES encryption flow on data …\nPerforms the <code>InvMixColumns</code> transformation on <code>a</code>.\nAssist in expanding the AES cipher key.\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte …\nComputes the bitwise AND of packed double-precision …\nBitwise AND of packed single-precision (32-bit) …\nComputes the bitwise AND of 128 bits (representing integer …\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.\nBitwise AND-NOT of packed single-precision (32-bit) …\nComputes the bitwise NOT of 128 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBlend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit integer vector into a 128-bit …\nCasts a 128-bit integer vector into a 128-bit …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nInvalidates and flushes the cache line that contains <code>p</code> …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower double-precision (64-bit) …\nCompare the lower double-precision (64-bit) floating-point …\nCompares the lower single-precision (32-bit) …\nCompare the lower single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for equality.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for equality. The …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than. …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for less-than.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than. The …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for not-equal.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for inequality. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for not-less-than. …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are ordered. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are unordered. The …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the signed 64-bit integer b to a double-precision …\nConvert the signed 64-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the signed 64-bit integer b to a double-precision …\nConvert the signed 64-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nAlias for <code>_mm_cvtsi32_ss</code>.\nAlias for <code>_mm_cvtss_si32</code>.\nSign extend packed 16-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 16-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts the lower two packed 32-bit integers in <code>a</code> to …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 16-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of <code>a</code> …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 32-bit integers in <code>a</code> to …\nConvert packed unsigned 32-bit integers in a to packed …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nConvert the signed 32-bit integer b to a double-precision …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the signed 64-bit integer b to a double-precision …\nConvert the signed 64-bit integer b to a single-precision …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 4 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 4 x 32-bit float values in the 128-bit vector …\nReturns the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConverts the lower double-precision (64-bit) …\nAlias for <code>_mm_cvtsd_si64</code>\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the lowest element of <code>a</code>.\nReturns the lowest element of <code>a</code>.\nReturns the lowest element of <code>a</code>.\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nConverts a 32 bit integer to a 32 bit float. The result …\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nConverts a 64 bit integer to a 32 bit float. The result …\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nExtracts the lowest 32 bit float from the input vector.\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lower single-precision (32-bit) …\nConverts the lowest 32 bit float in the input vector to a …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nAlias for <code>_mm_cvttss_si32</code>.\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConverts the lower double-precision (64-bit) …\nAlias for <code>_mm_cvttsd_si64</code>\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lowest 32 bit float in the input vector to a …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivides __m128 vectors.\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nDivides the first component of <code>b</code> by <code>a</code>, the other …\nReturns the dot product of two __m128d vectors.\nReturns the dot product of two __m128 vectors.\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nReturns the <code>imm8</code> element of <code>a</code>.\nExtracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code>\nExtracts an 64-bit integer from <code>a</code> selected with <code>IMM1</code>\nExtracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. …\nExtracts a single-precision (32-bit) floating-point …\nExtracts the bit range specified by <code>y</code> from the lower 64 …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nGets the unsigned 32-bit value of the MXCSR control and …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally subtract the adjacent pairs of values …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns a new vector where the <code>imm8</code> element of <code>a</code> is …\nReturns a copy of <code>a</code> with the 32-bit integer from <code>i</code> …\nReturns a copy of <code>a</code> with the 64-bit integer from <code>i</code> …\nReturns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted …\nSelect a single value in <code>a</code> to store at some position in <code>b</code>, …\nInserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.\nLoads 128-bits of integer data from unaligned memory. This …\nPerforms a serializing operation on all load-from-memory …\nLoads a double-precision (64-bit) floating-point element …\nConstruct a <code>__m128</code> by duplicating the value read from <code>p</code> …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads a double-precision (64-bit) floating-point element …\nLoads four <code>f32</code> values from <em>aligned</em> memory into a <code>__m128</code>. …\nAlias for <code>_mm_load1_ps</code>\nLoads a 64-bit double-precision value to the low element …\nLoads 128-bits of integer data from memory into a new …\nConstruct a <code>__m128</code> with the lowest element read from <code>p</code> and …\nLoads a double-precision (64-bit) floating-point element …\nLoads a double-precision value into the high-order bits of …\nLoads 64-bit integer from memory into first element of …\nLoads a double-precision value into the low-order bits of …\nLoads 2 double-precision (64-bit) floating-point elements …\nLoads four <code>f32</code> values from aligned memory into a <code>__m128</code> in …\nLoad 128-bits (composed of 8 packed 16-bit integers) from …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoad 128-bits (composed of 16 packed 8-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads four <code>f32</code> values from memory into a <code>__m128</code>. There are …\nLoads 128-bits of integer data from memory into a new …\nLoads unaligned 64-bits of integer data from memory into …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies and then horizontally add signed 16 bit …\nMultiplies corresponding pairs of packed 8-bit unsigned …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nConditionally store 8-bit integer elements from <code>a</code> into …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in th elow 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the maximum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nPerforms a serializing operation on all load-from-memory …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the minimum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nFinds the minimum unsigned 16-bit element in the 128-bit __…\nReturns a vector where the low element is extracted from <code>a</code> …\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code>…\nReturns a <code>__m128</code> with the first component from <code>b</code> and the …\nDuplicate the low double-precision (64-bit) floating-point …\nDuplicate odd-indexed single-precision (32-bit) …\nCombine higher half of <code>a</code> and <code>b</code>. The higher half of <code>b</code> …\nDuplicate even-indexed single-precision (32-bit) …\nCombine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nSubtracts 8-bit unsigned integer values and computes the …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies __m128 vectors.\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nMultiplies the first component of <code>a</code> and <code>b</code>, the other …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies packed 16-bit signed integer values, truncate …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR of <code>a</code> and <code>b</code>.\nBitwise OR of packed single-precision (32-bit) …\nComputes the bitwise OR of 128 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nProvides a hint to the processor that the code sequence is …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …")